/*!
 * @pixi-spine/all-3.8 - v4.0.3
 * Compiled Wed, 08 Feb 2023 14:56:53 UTC
 *
 * @pixi-spine/all-3.8 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine=function(I,D,$t,un,fn,yt,Bt){"use strict";var $=(e=>(e[e.Region=0]="Region",e[e.BoundingBox=1]="BoundingBox",e[e.Mesh=2]="Mesh",e[e.LinkedMesh=3]="LinkedMesh",e[e.Path=4]="Path",e[e.Point=5]="Point",e[e.Clipping=6]="Clipping",e))($||{});class De{constructor(t,n=new Array,s=0,r=new DataView(t.buffer)){this.strings=n,this.index=s,this.buffer=r}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let n=this.readByte(),s=n&127;return n&128&&(n=this.readByte(),s|=(n&127)<<7,n&128&&(n=this.readByte(),s|=(n&127)<<14,n&128&&(n=this.readByte(),s|=(n&127)<<21,n&128&&(n=this.readByte(),s|=(n&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let n="";for(let s=0;s<t;){const r=this.readUnsignedByte();switch(r>>4){case 12:case 13:n+=String.fromCharCode((r&31)<<6|this.readByte()&63),s+=2;break;case 14:n+=String.fromCharCode((r&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:n+=String.fromCharCode(r),s++}}return n}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}}var C=(e=>(e[e.setup=0]="setup",e[e.first=1]="first",e[e.replace=2]="replace",e[e.add=3]="add",e))(C||{}),lt=(e=>(e[e.mixIn=0]="mixIn",e[e.mixOut=1]="mixOut",e))(lt||{}),Ct=(e=>(e[e.Fixed=0]="Fixed",e[e.Percent=1]="Percent",e))(Ct||{}),It=(e=>(e[e.Tangent=0]="Tangent",e[e.Chain=1]="Chain",e[e.ChainScale=2]="ChainScale",e))(It||{}),z=(e=>(e[e.Normal=0]="Normal",e[e.OnlyTranslation=1]="OnlyTranslation",e[e.NoRotationOrReflection=2]="NoRotationOrReflection",e[e.NoScale=3]="NoScale",e[e.NoScaleOrReflection=4]="NoScaleOrReflection",e))(z||{});function me(e){switch(e.toLowerCase()){case"nearest":return ht.Nearest;case"linear":return ht.Linear;case"mipmap":return ht.MipMap;case"mipmapnearestnearest":return ht.MipMapNearestNearest;case"mipmaplinearnearest":return ht.MipMapLinearNearest;case"mipmapnearestlinear":return ht.MipMapNearestLinear;case"mipmaplinearlinear":return ht.MipMapLinearLinear;default:throw new Error(`Unknown texture filter ${e}`)}}function mn(e){switch(e.toLowerCase()){case"mirroredtepeat":return Rt.MirroredRepeat;case"clamptoedge":return Rt.ClampToEdge;case"repeat":return Rt.Repeat;default:throw new Error(`Unknown texture wrap ${e}`)}}var ht=(e=>(e[e.Nearest=9728]="Nearest",e[e.Linear=9729]="Linear",e[e.MipMap=9987]="MipMap",e[e.MipMapNearestNearest=9984]="MipMapNearestNearest",e[e.MipMapLinearNearest=9985]="MipMapLinearNearest",e[e.MipMapNearestLinear=9986]="MipMapNearestLinear",e[e.MipMapLinearLinear=9987]="MipMapLinearLinear",e))(ht||{}),Rt=(e=>(e[e.MirroredRepeat=33648]="MirroredRepeat",e[e.ClampToEdge=33071]="ClampToEdge",e[e.Repeat=10497]="Repeat",e))(Rt||{});class ee{constructor(){this.size=null,this.names=null,this.values=null,this.renderObject=null}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}}class gn{constructor(){this.x=0,this.y=0,this.width=0,this.height=0,this.offsetX=0,this.offsetY=0,this.originalWidth=0,this.originalHeight=0,this.rotate=0,this.index=0}}class ne{constructor(t,n,s){this.pages=new Array,this.regions=new Array,t&&this.addSpineAtlas(t,n,s)}addTexture(t,n){const s=this.pages;let r=null;for(let c=0;c<s.length;c++)if(s[c].baseTexture===n.baseTexture){r=s[c];break}if(r===null){r=new ge,r.name="texturePage";const c=n.baseTexture;r.width=c.realWidth,r.height=c.realHeight,r.baseTexture=c,r.minFilter=r.magFilter=ht.Nearest,r.uWrap=Rt.ClampToEdge,r.vWrap=Rt.ClampToEdge,s.push(r)}const l=new pe;return l.name=t,l.page=r,l.texture=n,l.index=-1,this.regions.push(l),l}addTextureHash(t,n){for(const s in t)t.hasOwnProperty(s)&&this.addTexture(n&&s.indexOf(".")!==-1?s.substr(0,s.lastIndexOf(".")):s,t[s])}addSpineAtlas(t,n,s){return this.load(t,n,s)}load(t,n,s){if(n==null)throw new Error("textureLoader cannot be null.");const r=new pn(t),l=new Array(4);let c=null;const o={};let i=null;o.size=()=>{c.width=parseInt(l[1]),c.height=parseInt(l[2])},o.format=()=>{},o.filter=()=>{c.minFilter=me(l[1]),c.magFilter=me(l[2])},o.repeat=()=>{l[1].indexOf("x")!=-1&&(c.uWrap=Rt.Repeat),l[1].indexOf("y")!=-1&&(c.vWrap=Rt.Repeat)},o.pma=()=>{c.pma=l[1]=="true"};const a={};a.xy=()=>{i.x=parseInt(l[1]),i.y=parseInt(l[2])},a.size=()=>{i.width=parseInt(l[1]),i.height=parseInt(l[2])},a.bounds=()=>{i.x=parseInt(l[1]),i.y=parseInt(l[2]),i.width=parseInt(l[3]),i.height=parseInt(l[4])},a.offset=()=>{i.offsetX=parseInt(l[1]),i.offsetY=parseInt(l[2])},a.orig=()=>{i.originalWidth=parseInt(l[1]),i.originalHeight=parseInt(l[2])},a.offsets=()=>{i.offsetX=parseInt(l[1]),i.offsetY=parseInt(l[2]),i.originalWidth=parseInt(l[3]),i.originalHeight=parseInt(l[4])},a.rotate=()=>{const d=l[1];let u=0;d.toLocaleLowerCase()=="true"?u=6:d.toLocaleLowerCase()=="false"?u=0:u=(720-parseFloat(d))%360/45,i.rotate=u},a.index=()=>{i.index=parseInt(l[1])};let h=r.readLine();for(;h!=null&&h.trim().length==0;)h=r.readLine();for(;!(h==null||h.trim().length==0||r.readEntry(l,h)==0);)h=r.readLine();const f=()=>{for(;;){if(h==null)return s&&s(this);if(h.trim().length==0)c=null,h=r.readLine();else if(c===null){for(c=new ge,c.name=h.trim();r.readEntry(l,h=r.readLine())!=0;){const d=o[l[0]];d&&d()}this.pages.push(c),n(c.name,d=>{if(d===null)return this.pages.splice(this.pages.indexOf(c),1),s&&s(null);c.baseTexture=d,c.pma&&(d.alphaMode=D.ALPHA_MODES.PMA),d.valid||d.setSize(c.width,c.height),c.setFilters(),(!c.width||!c.height)&&(c.width=d.realWidth,c.height=d.realHeight,(!c.width||!c.height)&&console.log(`ERROR spine atlas page ${c.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),f()});break}else{i=new gn;const d=new pe;d.name=h,d.page=c;let u=null,m=null;for(;;){const x=r.readEntry(l,h=r.readLine());if(x==0)break;const y=a[l[0]];if(y)y();else{u==null&&(u=[],m=[]),u.push(l[0]);const b=[];for(let M=0;M<x;M++)b.push(parseInt(l[M+1]));m.push(b)}}i.originalWidth==0&&i.originalHeight==0&&(i.originalWidth=i.width,i.originalHeight=i.height);const p=c.baseTexture.resolution;i.x/=p,i.y/=p,i.width/=p,i.height/=p,i.originalWidth/=p,i.originalHeight/=p,i.offsetX/=p,i.offsetY/=p;const g=i.rotate%4!==0,w=new D.Rectangle(i.x,i.y,g?i.height:i.width,g?i.width:i.height),S=new D.Rectangle(0,0,i.originalWidth,i.originalHeight),E=new D.Rectangle(i.offsetX,i.originalHeight-i.height-i.offsetY,i.width,i.height);d.texture=new D.Texture(d.page.baseTexture,w,S,E,i.rotate),d.index=i.index,d.texture.updateUvs(),this.regions.push(d)}}};f()}findRegion(t){for(let n=0;n<this.regions.length;n++)if(this.regions[n].name==t)return this.regions[n];return null}dispose(){for(let t=0;t<this.pages.length;t++)this.pages[t].baseTexture.dispose()}}class pn{constructor(t){this.index=0,this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(t,n){if(n==null||(n=n.trim(),n.length==0))return 0;const s=n.indexOf(":");if(s==-1)return 0;t[0]=n.substr(0,s).trim();for(let r=1,l=s+1;;r++){const c=n.indexOf(",",l);if(c==-1)return t[r]=n.substr(l).trim(),r;if(t[r]=n.substr(l,c-l).trim(),l=c+1,r==4)return 4}}}class ge{constructor(){this.minFilter=ht.Nearest,this.magFilter=ht.Nearest,this.uWrap=Rt.ClampToEdge,this.vWrap=Rt.ClampToEdge}setFilters(){const t=this.baseTexture,n=this.minFilter;n==ht.Linear?t.scaleMode=D.SCALE_MODES.LINEAR:this.minFilter==ht.Nearest?t.scaleMode=D.SCALE_MODES.NEAREST:(t.mipmap=D.MIPMAP_MODES.POW2,n==ht.MipMapNearestNearest?t.scaleMode=D.SCALE_MODES.NEAREST:t.scaleMode=D.SCALE_MODES.LINEAR)}}class pe extends ee{}class Xe{constructor(){this.array=new Array}add(t){const n=this.contains(t);return this.array[t|0]=t|0,!n}contains(t){return this.array[t|0]!=null}remove(t){this.array[t|0]=void 0}clear(){this.array.length=0}}class wn{constructor(){this.entries={},this.size=0}add(t){const n=this.entries[t];return this.entries[t]=!0,n?!1:(this.size++,!0)}addAll(t){const n=this.size;for(let s=0,r=t.length;s<r;s++)this.add(t[s]);return n!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}}const Wt=class{constructor(e=0,t=0,n=0,s=0){this.r=e,this.g=t,this.b=n,this.a=s}set(e,t,n,s){return this.r=e,this.g=t,this.b=n,this.a=s,this.clamp()}setFromColor(e){return this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a,this}setFromString(e){return e=e.charAt(0)=="#"?e.substr(1):e,this.r=parseInt(e.substr(0,2),16)/255,this.g=parseInt(e.substr(2,2),16)/255,this.b=parseInt(e.substr(4,2),16)/255,this.a=e.length!=8?1:parseInt(e.substr(6,2),16)/255,this}add(e,t,n,s){return this.r+=e,this.g+=t,this.b+=n,this.a+=s,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(e,t){e.r=((t&4278190080)>>>24)/255,e.g=((t&16711680)>>>16)/255,e.b=((t&65280)>>>8)/255,e.a=(t&255)/255}static rgb888ToColor(e,t){e.r=((t&16711680)>>>16)/255,e.g=((t&65280)>>>8)/255,e.b=(t&255)/255}static fromString(e){return new Wt().setFromString(e)}};let X=Wt;X.WHITE=new Wt(1,1,1,1),X.RED=new Wt(1,0,0,1),X.GREEN=new Wt(0,1,0,1),X.BLUE=new Wt(0,0,1,1),X.MAGENTA=new Wt(1,0,1,1);const Vt=class{static clamp(e,t,n){return e<t?t:e>n?n:e}static cosDeg(e){return Math.cos(e*Vt.degRad)}static sinDeg(e){return Math.sin(e*Vt.degRad)}static signum(e){return Math.sign(e)}static toInt(e){return e>0?Math.floor(e):Math.ceil(e)}static cbrt(e){const t=Math.pow(Math.abs(e),.3333333333333333);return e<0?-t:t}static randomTriangular(e,t){return Vt.randomTriangularWith(e,t,(e+t)*.5)}static randomTriangularWith(e,t,n){const s=Math.random(),r=t-e;return s<=(n-e)/r?e+Math.sqrt(s*r*(n-e)):t-Math.sqrt((1-s)*r*(t-n))}static isPowerOfTwo(e){return e&&(e&e-1)===0}};let A=Vt;A.PI=3.1415927,A.PI2=Vt.PI*2,A.radiansToDegrees=180/Vt.PI,A.radDeg=Vt.radiansToDegrees,A.degreesToRadians=Vt.PI/180,A.degRad=Vt.degreesToRadians;class Oe{apply(t,n,s){return t+(n-t)*this.applyInternal(s)}}class We extends Oe{constructor(t){super(),this.power=2,this.power=t}applyInternal(t){return t<=.5?Math.pow(t*2,this.power)/2:Math.pow((t-1)*2,this.power)/(this.power%2==0?-2:2)+1}}class Ue extends We{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}}const zt=class{static arrayCopy(e,t,n,s,r){for(let l=t,c=s;l<t+r;l++,c++)n[c]=e[l]}static arrayFill(e,t,n,s){for(let r=t;r<n;r++)e[r]=s}static setArraySize(e,t,n=0){const s=e.length;if(s==t)return e;if(e.length=t,s<t)for(let r=s;r<t;r++)e[r]=n;return e}static ensureArrayCapacity(e,t,n=0){return e.length>=t?e:zt.setArraySize(e,t,n)}static newArray(e,t){const n=new Array(e);for(let s=0;s<e;s++)n[s]=t;return n}static newFloatArray(e){if(zt.SUPPORTS_TYPED_ARRAYS)return new Float32Array(e);const t=new Array(e);for(let n=0;n<t.length;n++)t[n]=0;return t}static newShortArray(e){if(zt.SUPPORTS_TYPED_ARRAYS)return new Int16Array(e);const t=new Array(e);for(let n=0;n<t.length;n++)t[n]=0;return t}static toFloatArray(e){return zt.SUPPORTS_TYPED_ARRAYS?new Float32Array(e):e}static toSinglePrecision(e){return zt.SUPPORTS_TYPED_ARRAYS?Math.fround(e):e}static webkit602BugfixHelper(e,t){}static contains(e,t,n=!0){for(let s=0;s<e.length;s++)if(e[s]==t)return!0;return!1}static enumValue(e,t){return e[t[0].toUpperCase()+t.slice(1)]}};let k=zt;k.SUPPORTS_TYPED_ARRAYS=typeof Float32Array!="undefined";class xn{static logBones(t){for(let n=0;n<t.bones.length;n++){const s=t.bones[n],r=s.matrix;console.log(`${s.data.name}, ${r.a}, ${r.b}, ${r.c}, ${r.d}, ${r.tx}, ${r.ty}`)}}}class we{constructor(t){this.items=new Array,this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let n=0;n<t.length;n++)this.free(t[n])}clear(){this.items.length=0}}class qe{constructor(t=0,n=0){this.x=t,this.y=n}set(t,n){return this.x=t,this.y=n,this}length(){const t=this.x,n=this.y;return Math.sqrt(t*t+n*n)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}}class En{constructor(){this.maxDelta=.064,this.framesPerSecond=0,this.delta=0,this.totalTime=0,this.lastTime=Date.now()/1e3,this.frameCount=0,this.frameTime=0}update(){const t=Date.now()/1e3;this.delta=t-this.lastTime,this.frameTime+=this.delta,this.totalTime+=this.delta,this.delta>this.maxDelta&&(this.delta=this.maxDelta),this.lastTime=t,this.frameCount++,this.frameTime>1&&(this.framesPerSecond=this.frameCount/this.frameTime,this.frameTime=0,this.frameCount=0)}}class Sn{constructor(t=32){this.addedValues=0,this.lastValue=0,this.mean=0,this.dirty=!0,this.values=new Array(t)}hasEnoughData(){return this.addedValues>=this.values.length}addValue(t){this.addedValues<this.values.length&&this.addedValues++,this.values[this.lastValue++]=t,this.lastValue>this.values.length-1&&(this.lastValue=0),this.dirty=!0}getMean(){if(this.hasEnoughData()){if(this.dirty){let t=0;for(let n=0;n<this.values.length;n++)t+=this.values[n];this.mean=t/this.values.length,this.dirty=!1}return this.mean}return 0}}class xe{constructor(){this.minX=0,this.minY=0,this.maxX=0,this.maxY=0,this.boundingBoxes=new Array,this.polygons=new Array,this.polygonPool=new we(()=>k.newFloatArray(16))}update(t,n){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,r=this.polygons,l=this.polygonPool,c=t.slots,o=c.length;s.length=0,l.freeAll(r),r.length=0;for(let i=0;i<o;i++){const a=c[i];if(!a.bone.active)continue;const h=a.getAttachment();if(h!=null&&h.type===$.BoundingBox){const f=h;s.push(f);let d=l.obtain();d.length!=f.worldVerticesLength&&(d=k.newFloatArray(f.worldVerticesLength)),r.push(d),f.computeWorldVertices(a,0,f.worldVerticesLength,d,0,2)}}n?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,r=Number.NEGATIVE_INFINITY;const l=this.polygons;for(let c=0,o=l.length;c<o;c++){const i=l[c],a=i;for(let h=0,f=i.length;h<f;h+=2){const d=a[h],u=a[h+1];t=Math.min(t,d),n=Math.min(n,u),s=Math.max(s,d),r=Math.max(r,u)}}this.minX=t,this.minY=n,this.maxX=s,this.maxY=r}aabbContainsPoint(t,n){return t>=this.minX&&t<=this.maxX&&n>=this.minY&&n<=this.maxY}aabbIntersectsSegment(t,n,s,r){const l=this.minX,c=this.minY,o=this.maxX,i=this.maxY;if(t<=l&&s<=l||n<=c&&r<=c||t>=o&&s>=o||n>=i&&r>=i)return!1;const a=(r-n)/(s-t);let h=a*(l-t)+n;if(h>c&&h<i||(h=a*(o-t)+n,h>c&&h<i))return!0;let f=(c-n)/a+t;return f>l&&f<o||(f=(i-n)/a+t,f>l&&f<o)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,n){const s=this.polygons;for(let r=0,l=s.length;r<l;r++)if(this.containsPointPolygon(s[r],t,n))return this.boundingBoxes[r];return null}containsPointPolygon(t,n,s){const r=t,l=t.length;let c=l-2,o=!1;for(let i=0;i<l;i+=2){const a=r[i+1],h=r[c+1];if(a<s&&h>=s||h<s&&a>=s){const f=r[i];f+(s-a)/(h-a)*(r[c]-f)<n&&(o=!o)}c=i}return o}intersectsSegment(t,n,s,r){const l=this.polygons;for(let c=0,o=l.length;c<o;c++)if(this.intersectsSegmentPolygon(l[c],t,n,s,r))return this.boundingBoxes[c];return null}intersectsSegmentPolygon(t,n,s,r,l){const c=t,o=t.length,i=n-r,a=s-l,h=n*l-s*r;let f=c[o-2],d=c[o-1];for(let u=0;u<o;u+=2){const m=c[u],p=c[u+1],g=f*p-d*m,w=f-m,S=d-p,E=i*S-a*w,x=(h*w-i*g)/E;if((x>=f&&x<=m||x>=m&&x<=f)&&(x>=n&&x<=r||x>=r&&x<=n)){const y=(h*S-a*g)/E;if((y>=d&&y<=p||y>=p&&y<=d)&&(y>=s&&y<=l||y>=l&&y<=s))return!0}f=m,d=p}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const n=this.boundingBoxes.indexOf(t);return n==-1?null:this.polygons[n]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}}const Zt={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0},Yt=[0,0,0];class He extends un.Sprite{constructor(){super(...arguments),this.region=null,this.attachment=null}}class Ge extends fn.SimpleMesh{constructor(t,n,s,r,l){super(t,n,s,r,l),this.region=null,this.attachment=null}}const $e=class extends $t.Container{constructor(e){if(super(),!e)throw new Error("The spineData param is required.");if(typeof e=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=e,this.createSkeleton(e),this.slotContainers=[],this.tempClipContainers=[];for(let t=0,n=this.skeleton.slots.length;t<n;t++){const s=this.skeleton.slots[t],r=s.getAttachment(),l=this.newContainer();if(this.slotContainers.push(l),this.addChild(l),this.tempClipContainers.push(null),!!r)if(r.type===$.Region){const c=r.name,o=this.createSprite(s,r,c);s.currentSprite=o,s.currentSpriteName=c,l.addChild(o)}else if(r.type===$.Mesh){const c=this.createMesh(s,r);s.currentMesh=c,s.currentMeshId=r.id,s.currentMeshName=r.name,l.addChild(c)}else r.type===$.Clipping&&(this.createGraphics(s,r),l.addChild(s.clippingContainer),l.addChild(s.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(e){var t;e!=this._debug&&((t=this._debug)==null||t.unregisterSpine(this),e==null||e.registerSpine(this),this._debug=e)}get autoUpdate(){return this._autoUpdate}set autoUpdate(e){e!==this._autoUpdate&&(this._autoUpdate=e,this.updateTransform=e?$e.prototype.autoUpdateTransform:$t.Container.prototype.updateTransform)}get tint(){return D.utils.rgb2hex(this.tintRgb)}set tint(e){this.tintRgb=D.utils.hex2rgb(e,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:Zt.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(e){var a;const t=this.delayLimit;if(e>t&&(e=t),this.state.update(e),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform();const n=this.skeleton.slots,s=this.color;let r=null,l=null;s?(r=s.light,l=s.dark):r=this.tintRgb;for(let h=0,f=n.length;h<f;h++){const d=n[h],u=d.getAttachment(),m=this.slotContainers[h];if(!u){m.visible=!1;continue}let p=null;u.sequence&&u.sequence.apply(d,u);let g=u.region;const w=u.color;switch(u!=null&&u.type){case $.Region:if(m.transform.setFromMatrix(d.bone.matrix),g=u.region,d.currentMesh&&(d.currentMesh.visible=!1,d.currentMesh=null,d.currentMeshId=void 0,d.currentMeshName=void 0),!g){d.currentSprite&&(d.currentSprite.renderable=!1);break}if(!d.currentSpriteName||d.currentSpriteName!==u.name){const x=u.name;if(d.currentSprite&&(d.currentSprite.visible=!1),d.sprites=d.sprites||{},d.sprites[x]!==void 0)d.sprites[x].visible=!0;else{const y=this.createSprite(d,u,x);m.addChild(y)}d.currentSprite=d.sprites[x],d.currentSpriteName=x}d.currentSprite.renderable=!0,d.hackRegion||this.setSpriteRegion(u,d.currentSprite,g),d.currentSprite.color?p=d.currentSprite.color:(Yt[0]=r[0]*d.color.r*w.r,Yt[1]=r[1]*d.color.g*w.g,Yt[2]=r[2]*d.color.b*w.b,d.currentSprite.tint=D.utils.rgb2hex(Yt)),d.currentSprite.blendMode=d.blendMode;break;case $.Mesh:if(d.currentSprite){d.currentSprite.visible=!1,d.currentSprite=null,d.currentSpriteName=void 0;const x=new D.Transform;x._parentID=-1,x._worldID=m.transform._worldID,m.transform=x}if(!g){d.currentMesh&&(d.currentMesh.renderable=!1);break}const E=u.id;if(d.currentMeshId===void 0||d.currentMeshId!==E){const x=E;if(d.currentMesh&&(d.currentMesh.visible=!1),d.meshes=d.meshes||{},d.meshes[x]!==void 0)d.meshes[x].visible=!0;else{const y=this.createMesh(d,u);m.addChild(y)}d.currentMesh=d.meshes[x],d.currentMeshName=u.name,d.currentMeshId=x}d.currentMesh.renderable=!0,u.computeWorldVerticesOld(d,d.currentMesh.vertices),d.currentMesh.color?p=d.currentMesh.color:(Yt[0]=r[0]*d.color.r*w.r,Yt[1]=r[1]*d.color.g*w.g,Yt[2]=r[2]*d.color.b*w.b,d.currentMesh.tint=D.utils.rgb2hex(Yt)),d.currentMesh.blendMode=d.blendMode,d.hackRegion||this.setMeshRegion(u,d.currentMesh,g);break;case $.Clipping:d.currentGraphics||(this.createGraphics(d,u),m.addChild(d.clippingContainer),m.addChild(d.currentGraphics)),this.updateGraphics(d,u),m.alpha=1,m.visible=!0;continue;default:m.visible=!1;continue}if(m.visible=!0,p){let S=d.color.r*w.r,E=d.color.g*w.g,x=d.color.b*w.b;p.setLight(r[0]*S+l[0]*(1-S),r[1]*E+l[1]*(1-E),r[2]*x+l[2]*(1-x)),d.darkColor?(S=d.darkColor.r,E=d.darkColor.g,x=d.darkColor.b):(S=0,E=0,x=0),p.setDark(r[0]*S+l[0]*(1-S),r[1]*E+l[1]*(1-E),r[2]*x+l[2]*(1-x))}m.alpha=d.color.a}const c=this.skeleton.drawOrder;let o=null,i=null;for(let h=0,f=c.length;h<f;h++){const d=n[c[h].data.index],u=this.slotContainers[c[h].data.index];if(i||u.parent!==null&&u.parent!==this&&(u.parent.removeChild(u),u.parent=this),d.currentGraphics&&d.getAttachment())i=d.clippingContainer,o=d.getAttachment(),i.children.length=0,this.children[h]=u,o.endSlot===d.data&&(o.endSlot=null);else if(i){let m=this.tempClipContainers[h];m||(m=this.tempClipContainers[h]=this.newContainer(),m.visible=!1),this.children[h]=m,u.parent=null,i.addChild(u),o.endSlot==d.data&&(i.renderable=!0,i=null,o=null)}else this.children[h]=u}(a=this._debug)==null||a.renderDebug(this)}setSpriteRegion(e,t,n){t.attachment===e&&t.region===n||(t.region=n,t.attachment=e,t.texture=n.texture,t.rotation=e.rotation*A.degRad,t.position.x=e.x,t.position.y=e.y,t.alpha=e.color.a,n.size?(t.scale.x=n.size.width/n.originalWidth,t.scale.y=-n.size.height/n.originalHeight):(t.scale.x=e.scaleX*e.width/n.originalWidth,t.scale.y=-e.scaleY*e.height/n.originalHeight))}setMeshRegion(e,t,n){t.attachment===e&&t.region===n||(t.region=n,t.attachment=e,t.texture=n.texture,n.texture.updateUvs(),t.uvBuffer.update(e.regionUVs))}autoUpdateTransform(){if(Zt.GLOBAL_AUTO_UPDATE){this.lastTime=this.lastTime||Date.now();const e=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(e)}else this.lastTime=0;$t.Container.prototype.updateTransform.call(this)}createSprite(e,t,n){let s=t.region;e.hackAttachment===t&&(s=e.hackRegion);const r=s?s.texture:null,l=this.newSprite(r);return l.anchor.set(.5),s&&this.setSpriteRegion(t,l,t.region),e.sprites=e.sprites||{},e.sprites[n]=l,l}createMesh(e,t){let n=t.region;e.hackAttachment===t&&(n=e.hackRegion,e.hackAttachment=null,e.hackRegion=null);const s=this.newMesh(n?n.texture:null,new Float32Array(t.regionUVs.length),t.regionUVs,new Uint16Array(t.triangles),D.DRAW_MODES.TRIANGLES);return typeof s._canvasPadding!="undefined"&&(s._canvasPadding=1.5),s.alpha=t.color.a,s.region=t.region,n&&this.setMeshRegion(t,s,n),e.meshes=e.meshes||{},e.meshes[t.id]=s,s}createGraphics(e,t){const n=this.newGraphics(),s=new D.Polygon([]);return n.clear(),n.beginFill(16777215,1),n.drawPolygon(s),n.renderable=!1,e.currentGraphics=n,e.clippingContainer=this.newContainer(),e.clippingContainer.mask=e.currentGraphics,n}updateGraphics(e,t){const n=e.currentGraphics.geometry,s=n.graphicsData[0].shape.points,r=t.worldVerticesLength;s.length=r,t.computeWorldVertices(e,0,r,s,0,2),n.invalidate()}hackTextureBySlotIndex(e,t=null,n=null){const s=this.skeleton.slots[e];if(!s)return!1;const r=s.getAttachment();let l=r.region;return t?(l=new ee,l.texture=t,l.size=n,s.hackRegion=l,s.hackAttachment=r):(s.hackRegion=null,s.hackAttachment=null),s.currentSprite?this.setSpriteRegion(r,s.currentSprite,l):s.currentMesh&&this.setMeshRegion(r,s.currentMesh,l),!0}hackTextureBySlotName(e,t=null,n=null){const s=this.skeleton.findSlotIndex(e);return s==-1?!1:this.hackTextureBySlotIndex(s,t,n)}hackTextureAttachment(e,t,n,s=null){const r=this.skeleton.findSlotIndex(e),l=this.skeleton.getAttachmentByName(e,t);l.region.texture=n;const c=this.skeleton.slots[r];if(!c)return!1;const o=c.getAttachment();if(t===o.name){let i=l.region;return n?(i=new ee,i.texture=n,i.size=s,c.hackRegion=i,c.hackAttachment=o):(c.hackRegion=null,c.hackAttachment=null),c.currentSprite&&c.currentSprite.region!=i?(this.setSpriteRegion(o,c.currentSprite,i),c.currentSprite.region=i):c.currentMesh&&c.currentMesh.region!=i&&this.setMeshRegion(o,c.currentMesh,i),!0}return!1}newContainer(){return new $t.Container}newSprite(e){return new He(e)}newGraphics(){return new yt.Graphics}newMesh(e,t,n,s,r){return new Ge(e,t,n,s,r)}transformHack(){return 1}hackAttachmentGroups(e,t,n){if(!e)return;const s=[],r=[];for(let l=0,c=this.skeleton.slots.length;l<c;l++){const o=this.skeleton.slots[l],i=o.currentSpriteName||o.currentMeshName||"",a=o.currentSprite||o.currentMesh;i.endsWith(e)?(a.parentGroup=t,r.push(a)):n&&a&&(a.parentGroup=n,s.push(a))}return[s,r]}destroy(e){this.debug=null;for(let t=0,n=this.skeleton.slots.length;t<n;t++){const s=this.skeleton.slots[t];for(const r in s.meshes)s.meshes[r].destroy(e);s.meshes=null;for(const r in s.sprites)s.sprites[r].destroy(e);s.sprites=null}for(let t=0,n=this.slotContainers.length;t<n;t++)this.slotContainers[t].destroy(e);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(e)}};let se=$e;se.clippingPolygon=[],Object.defineProperty(se.prototype,"visible",{get(){return this._visible},set(e){e!==this._visible&&(this._visible=e,e&&(this.lastTime=0))}});class bn{constructor(){this.registeredSpines=new Map,this.drawDebug=!0,this.drawMeshHull=!0,this.drawMeshTriangles=!0,this.drawBones=!0,this.drawPaths=!0,this.drawBoundingBoxes=!0,this.drawClipping=!0,this.drawRegionAttachments=!0,this.lineWidth=1,this.regionAttachmentsColor=30975,this.meshHullColor=30975,this.meshTrianglesColor=16763904,this.clippingPolygonColor=16711935,this.boundingBoxesRectColor=65280,this.boundingBoxesPolygonColor=65280,this.boundingBoxesCircleColor=65280,this.pathsCurveColor=16711680,this.pathsLineColor=16711935,this.skeletonXYColor=16711680,this.bonesColor=61132}registerSpine(t){this.registeredSpines.has(t)&&console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!",t);const n={parentDebugContainer:new $t.Container,bones:new $t.Container,skeletonXY:new yt.Graphics,regionAttachmentsShape:new yt.Graphics,meshTrianglesLine:new yt.Graphics,meshHullLine:new yt.Graphics,clippingPolygon:new yt.Graphics,boundingBoxesRect:new yt.Graphics,boundingBoxesCircle:new yt.Graphics,boundingBoxesPolygon:new yt.Graphics,pathsCurve:new yt.Graphics,pathsLine:new yt.Graphics};n.parentDebugContainer.addChild(n.bones),n.parentDebugContainer.addChild(n.skeletonXY),n.parentDebugContainer.addChild(n.regionAttachmentsShape),n.parentDebugContainer.addChild(n.meshTrianglesLine),n.parentDebugContainer.addChild(n.meshHullLine),n.parentDebugContainer.addChild(n.clippingPolygon),n.parentDebugContainer.addChild(n.boundingBoxesRect),n.parentDebugContainer.addChild(n.boundingBoxesCircle),n.parentDebugContainer.addChild(n.boundingBoxesPolygon),n.parentDebugContainer.addChild(n.pathsCurve),n.parentDebugContainer.addChild(n.pathsLine),t.addChild(n.parentDebugContainer),this.registeredSpines.set(t,n)}renderDebug(t){this.registeredSpines.has(t)||this.registerSpine(t);const n=this.registeredSpines.get(t);n.skeletonXY.clear(),n.regionAttachmentsShape.clear(),n.meshTrianglesLine.clear(),n.meshHullLine.clear(),n.clippingPolygon.clear(),n.boundingBoxesRect.clear(),n.boundingBoxesCircle.clear(),n.boundingBoxesPolygon.clear(),n.pathsCurve.clear(),n.pathsLine.clear();for(let l=n.bones.children.length;l>0;l--)n.bones.children[l-1].destroy({children:!0,texture:!0,baseTexture:!0});const s=t.scale.x||t.scale.y||1,r=this.lineWidth/s;this.drawBones&&this.drawBonesFunc(t,n,r,s),this.drawPaths&&this.drawPathsFunc(t,n,r),this.drawBoundingBoxes&&this.drawBoundingBoxesFunc(t,n,r),this.drawClipping&&this.drawClippingFunc(t,n,r),(this.drawMeshHull||this.drawMeshTriangles)&&this.drawMeshHullAndMeshTriangles(t,n,r),this.drawRegionAttachments&&this.drawRegionAttachmentsFunc(t,n,r)}drawBonesFunc(t,n,s,r){const l=t.skeleton,c=l.x,o=l.y,i=l.bones;n.skeletonXY.lineStyle(s,this.skeletonXYColor,1);for(let h=0,f=i.length;h<f;h++){const d=i[h],u=d.data.length,m=c+d.matrix.tx,p=o+d.matrix.ty,g=c+u*d.matrix.a+d.matrix.tx,w=o+u*d.matrix.b+d.matrix.ty;if(d.data.name==="root"||d.data.parent===null)continue;const S=Math.abs(m-g),E=Math.abs(p-w),x=Math.pow(S,2),y=E,b=Math.pow(E,2),M=Math.sqrt(x+b),T=Math.pow(M,2),R=Math.PI/180,P=Math.acos((T+b-x)/(2*y*M))||0;if(M===0)continue;const v=new yt.Graphics;n.bones.addChild(v);const _=M/50/r;v.beginFill(this.bonesColor,1),v.drawPolygon(0,0,0-_,M-_*3,0,M-_,0+_,M-_*3),v.endFill(),v.x=m,v.y=p,v.pivot.y=M;let B=0;m<g&&p<w?B=-P+180*R:m>g&&p<w?B=180*R+P:m>g&&p>w?B=-P:m<g&&p>w?B=P:p===w&&m<g?B=90*R:p===w&&m>g?B=-90*R:m===g&&p<w?B=180*R:m===g&&p>w&&(B=0),v.rotation=B,v.lineStyle(s+_/2.4,this.bonesColor,1),v.beginFill(0,.6),v.drawCircle(0,M,_*1.2),v.endFill()}const a=s*3;n.skeletonXY.moveTo(c-a,o-a),n.skeletonXY.lineTo(c+a,o+a),n.skeletonXY.moveTo(c+a,o-a),n.skeletonXY.lineTo(c-a,o+a)}drawRegionAttachmentsFunc(t,n,s){const l=t.skeleton.slots;n.regionAttachmentsShape.lineStyle(s,this.regionAttachmentsColor,1);for(let c=0,o=l.length;c<o;c++){const i=l[c],a=i.getAttachment();if(a==null||a.type!==$.Region)continue;const h=a,f=new Float32Array(8);h.updateOffset&&h.updateOffset(),h.computeWorldVertices(i,f,0,2),n.regionAttachmentsShape.drawPolygon(Array.from(f.slice(0,8)))}}drawMeshHullAndMeshTriangles(t,n,s){const l=t.skeleton.slots;n.meshHullLine.lineStyle(s,this.meshHullColor,1),n.meshTrianglesLine.lineStyle(s,this.meshTrianglesColor,1);for(let c=0,o=l.length;c<o;c++){const i=l[c];if(!i.bone.active)continue;const a=i.getAttachment();if(a==null||a.type!==$.Mesh)continue;const h=a,f=new Float32Array(h.worldVerticesLength),d=h.triangles;let u=h.hullLength;if(h.computeWorldVertices(i,0,h.worldVerticesLength,f,0,2),this.drawMeshTriangles)for(let m=0,p=d.length;m<p;m+=3){const g=d[m]*2,w=d[m+1]*2,S=d[m+2]*2;n.meshTrianglesLine.moveTo(f[g],f[g+1]),n.meshTrianglesLine.lineTo(f[w],f[w+1]),n.meshTrianglesLine.lineTo(f[S],f[S+1])}if(this.drawMeshHull&&u>0){u=(u>>1)*2;let m=f[u-2],p=f[u-1];for(let g=0,w=u;g<w;g+=2){const S=f[g],E=f[g+1];n.meshHullLine.moveTo(S,E),n.meshHullLine.lineTo(m,p),m=S,p=E}}}}drawClippingFunc(t,n,s){const l=t.skeleton.slots;n.clippingPolygon.lineStyle(s,this.clippingPolygonColor,1);for(let c=0,o=l.length;c<o;c++){const i=l[c];if(!i.bone.active)continue;const a=i.getAttachment();if(a==null||a.type!==$.Clipping)continue;const h=a,f=h.worldVerticesLength,d=new Float32Array(f);h.computeWorldVertices(i,0,f,d,0,2),n.clippingPolygon.drawPolygon(Array.from(d))}}drawBoundingBoxesFunc(t,n,s){n.boundingBoxesRect.lineStyle(s,this.boundingBoxesRectColor,5);const r=new xe;r.update(t.skeleton,!0),n.boundingBoxesRect.drawRect(r.minX,r.minY,r.getWidth(),r.getHeight());const l=r.polygons,c=(o,i,a)=>{if(n.boundingBoxesPolygon.lineStyle(s,this.boundingBoxesPolygonColor,1),n.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor,.1),a<3)throw new Error("Polygon must contain at least 3 vertices");const h=[],f=s*2;for(let d=0,u=o.length;d<u;d+=2){const m=o[d],p=o[d+1];n.boundingBoxesCircle.lineStyle(0),n.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor),n.boundingBoxesCircle.drawCircle(m,p,f),n.boundingBoxesCircle.endFill(),h.push(m,p)}n.boundingBoxesPolygon.drawPolygon(h),n.boundingBoxesPolygon.endFill()};for(let o=0,i=l.length;o<i;o++){const a=l[o];c(a,0,a.length)}}drawPathsFunc(t,n,s){const l=t.skeleton.slots;n.pathsCurve.lineStyle(s,this.pathsCurveColor,1),n.pathsLine.lineStyle(s,this.pathsLineColor,1);for(let c=0,o=l.length;c<o;c++){const i=l[c];if(!i.bone.active)continue;const a=i.getAttachment();if(a==null||a.type!==$.Path)continue;const h=a;let f=h.worldVerticesLength;const d=new Float32Array(f);h.computeWorldVertices(i,0,f,d,0,2);let u=d[2],m=d[3],p=0,g=0;if(h.closed){const w=d[0],S=d[1],E=d[f-2],x=d[f-1];p=d[f-4],g=d[f-3],n.pathsCurve.moveTo(u,m),n.pathsCurve.bezierCurveTo(w,S,E,x,p,g),n.pathsLine.moveTo(u,m),n.pathsLine.lineTo(w,S),n.pathsLine.moveTo(p,g),n.pathsLine.lineTo(E,x)}f-=4;for(let w=4;w<f;w+=6){const S=d[w],E=d[w+1],x=d[w+2],y=d[w+3];p=d[w+4],g=d[w+5],n.pathsCurve.moveTo(u,m),n.pathsCurve.bezierCurveTo(S,E,x,y,p,g),n.pathsLine.moveTo(u,m),n.pathsLine.lineTo(S,E),n.pathsLine.moveTo(p,g),n.pathsLine.lineTo(x,y),u=p,m=g}}}unregisterSpine(t){this.registeredSpines.has(t)||console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!",t),this.registeredSpines.get(t).parentDebugContainer.destroy({baseTexture:!0,children:!0,texture:!0}),this.registeredSpines.delete(t)}}const Mn={extension:D.ExtensionType.Asset,loader:{extension:{type:D.ExtensionType.LoadParser,priority:Bt.LoaderParserPriority.Normal},test(e){return Bt.checkExtension(e,".atlas")},async load(e){return await(await D.settings.ADAPTER.fetch(e)).text()},testParse(e,t){const n=Bt.checkExtension(t.src,".atlas"),s=typeof e=="string";return Promise.resolve(n&&s)},async parse(e,t,n){const s=t.data;let r=D.utils.path.dirname(t.src);r&&r.lastIndexOf("/")!==r.length-1&&(r+="/");let l=null,c=null;const o=new Promise((h,f)=>{l=h,c=f});let i;const a=h=>{h||c(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),l(i)};if(s.image||s.images){const h=Object.assign(s.image?{default:s.image}:{},s.images);i=new ne(e,(f,d)=>{const u=h[f]||h.default;u&&u.baseTexture?d(u.baseTexture):d(u)},a)}else i=new ne(e,ze(n,r,s.imageMetadata),a);return await o},unload(e){e.dispose()}}},ze=(e,t,n)=>async(s,r)=>{const l=D.utils.path.join(...t.split(D.utils.path.sep),s),c=await e.load({src:l,data:n});r(c.baseTexture)};D.extensions.add(Mn);function Ze(e){return e.hasOwnProperty("bones")}function yn(e){return e instanceof ArrayBuffer}class An{constructor(){}installLoader(){const t=this,n={extension:D.ExtensionType.Asset,loader:{extension:{type:D.ExtensionType.LoadParser,priority:Bt.LoaderParserPriority.Normal},test(s){return Bt.checkExtension(s,".skel")},async load(s){return await(await D.settings.ADAPTER.fetch(s)).arrayBuffer()},testParse(s,r){var i;const l=Bt.checkExtension(r.src,".json")&&Ze(s),c=Bt.checkExtension(r.src,".skel")&&yn(s),o=((i=r.data)==null?void 0:i.spineAtlas)===!1;return Promise.resolve(l&&!o||c)},async parse(s,r,l){var S;const c=D.utils.path.extname(r.src).toLowerCase(),o=D.utils.path.basename(r.src,c);let i=D.utils.path.dirname(r.src);i&&i.lastIndexOf("/")!==i.length-1&&(i+="/");const a=Bt.checkExtension(r.src,".json")&&Ze(s);let h=null,f=s;a?h=t.createJsonParser():(h=t.createBinaryParser(),f=new Uint8Array(s));const d=r.data||{},u=(S=d==null?void 0:d.spineSkeletonScale)!=null?S:null;u&&(h.scale=u);const m=d.spineAtlas;if(m&&m.pages)return t.parseData(h,m,f);const p=d.atlasRawData;if(p){let E=null,x=null;const y=new Promise((T,R)=>{E=T,x=R}),b=new ne(p,ze(l,i,d.imageMetadata),T=>{T||x(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),E(b)}),M=await y;return t.parseData(h,M,f)}let g=d.spineAtlasFile;g||(g=`${i+o}.atlas`);const w=await l.load({src:g,data:d,alias:d.spineAtlasAlias});return t.parseData(h,w,f)}}};return D.extensions.add(n),n}}class Ee{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}}const je=class extends Ee{constructor(e){super(e),this.id=(je.nextID++&65535)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(e,t){this.computeWorldVertices(e,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(e,t,n,s,r,l){n=r+(n>>1)*l;const c=e.bone.skeleton,o=e.deform;let i=this.vertices;const a=this.bones;if(a==null){o.length>0&&(i=o);const u=e.bone.matrix,m=u.tx,p=u.ty,g=u.a,w=u.c,S=u.b,E=u.d;for(let x=t,y=r;y<n;x+=2,y+=l){const b=i[x],M=i[x+1];s[y]=b*g+M*w+m,s[y+1]=b*S+M*E+p}return}let h=0,f=0;for(let u=0;u<t;u+=2){const m=a[h];h+=m+1,f+=m}const d=c.bones;if(o.length==0)for(let u=r,m=f*3;u<n;u+=l){let p=0,g=0,w=a[h++];for(w+=h;h<w;h++,m+=3){const S=d[a[h]].matrix,E=i[m],x=i[m+1],y=i[m+2];p+=(E*S.a+x*S.c+S.tx)*y,g+=(E*S.b+x*S.d+S.ty)*y}s[u]=p,s[u+1]=g}else{const u=o;for(let m=r,p=f*3,g=f<<1;m<n;m+=l){let w=0,S=0,E=a[h++];for(E+=h;h<E;h++,p+=3,g+=2){const x=d[a[h]].matrix,y=i[p]+u[g],b=i[p+1]+u[g+1],M=i[p+2];w+=(y*x.a+b*x.c+x.tx)*M,S+=(y*x.b+b*x.d+x.ty)*M}s[m]=w,s[m+1]=S}}}copyTo(e){this.bones!=null?(e.bones=new Array(this.bones.length),k.arrayCopy(this.bones,0,e.bones,0,this.bones.length)):e.bones=null,this.vertices!=null?(e.vertices=k.newFloatArray(this.vertices.length),k.arrayCopy(this.vertices,0,e.vertices,0,this.vertices.length)):e.vertices=null,e.worldVerticesLength=this.worldVerticesLength,e.deformAttachment=this.deformAttachment}};let _t=je;_t.nextID=0;class re extends _t{constructor(t){super(t),this.type=$.BoundingBox,this.color=new X(1,1,1,1)}copy(){const t=new re(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class ie extends _t{constructor(t){super(t),this.type=$.Clipping,this.color=new X(.2275,.2275,.8078,1)}copy(){const t=new ie(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class Ut extends _t{constructor(t){super(t),this.type=$.Mesh,this.color=new X(1,1,1,1),this.tempColor=new X(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new Ut(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),k.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),k.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),k.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Ut(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}}class qt extends _t{constructor(t){super(t),this.type=$.Path,this.closed=!1,this.constantSpeed=!1,this.color=new X(1,1,1,1)}copy(){const t=new qt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),k.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class ae extends _t{constructor(t){super(t),this.type=$.Point,this.color=new X(.38,.94,0,1)}computeWorldPosition(t,n){const s=t.matrix;return n.x=this.x*s.a+this.y*s.c+t.worldX,n.y=this.x*s.b+this.y*s.d+t.worldY,n}computeWorldRotation(t){const n=t.matrix,s=A.cosDeg(this.rotation),r=A.sinDeg(this.rotation),l=s*n.a+r*n.c,c=s*n.b+r*n.d;return Math.atan2(c,l)*A.radDeg}copy(){const t=new ae(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class Se{constructor(t,n){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("bone cannot be null.");this.data=t,this.bone=n,this.color=new X,this.darkColor=t.darkColor==null?null:new X,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const rt=class extends Ee{constructor(e){super(e),this.type=$.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new X(1,1,1,1),this.offset=k.newFloatArray(8),this.uvs=k.newFloatArray(8),this.tempColor=new X(1,1,1,1)}updateOffset(){const e=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*e,s=-this.height/2*this.scaleY+this.region.offsetY*t,r=n+this.region.width*e,l=s+this.region.height*t,c=this.rotation*Math.PI/180,o=Math.cos(c),i=Math.sin(c),a=n*o+this.x,h=n*i,f=s*o+this.y,d=s*i,u=r*o+this.x,m=r*i,p=l*o+this.y,g=l*i,w=this.offset;w[rt.OX1]=a-d,w[rt.OY1]=f+h,w[rt.OX2]=a-g,w[rt.OY2]=p+h,w[rt.OX3]=u-g,w[rt.OY3]=p+m,w[rt.OX4]=u-d,w[rt.OY4]=f+m}setRegion(e){this.region=e;const t=this.uvs;e.rotate?(t[2]=e.u,t[3]=e.v2,t[4]=e.u,t[5]=e.v,t[6]=e.u2,t[7]=e.v,t[0]=e.u2,t[1]=e.v2):(t[0]=e.u,t[1]=e.v2,t[2]=e.u,t[3]=e.v,t[4]=e.u2,t[5]=e.v,t[6]=e.u2,t[7]=e.v2)}computeWorldVertices(e,t,n,s){const r=this.offset,l=e instanceof Se?e.bone.matrix:e.matrix,c=l.tx,o=l.ty,i=l.a,a=l.c,h=l.b,f=l.d;let d=0,u=0;d=r[rt.OX1],u=r[rt.OY1],t[n]=d*i+u*a+c,t[n+1]=d*h+u*f+o,n+=s,d=r[rt.OX2],u=r[rt.OY2],t[n]=d*i+u*a+c,t[n+1]=d*h+u*f+o,n+=s,d=r[rt.OX3],u=r[rt.OY3],t[n]=d*i+u*a+c,t[n+1]=d*h+u*f+o,n+=s,d=r[rt.OX4],u=r[rt.OY4],t[n]=d*i+u*a+c,t[n+1]=d*h+u*f+o}copy(){const e=new rt(this.name);return e.region=this.region,e.rendererObject=this.rendererObject,e.path=this.path,e.x=this.x,e.y=this.y,e.scaleX=this.scaleX,e.scaleY=this.scaleY,e.rotation=this.rotation,e.width=this.width,e.height=this.height,k.arrayCopy(this.uvs,0,e.uvs,0,8),k.arrayCopy(this.offset,0,e.offset,0,8),e.color.setFromColor(this.color),e}};let L=rt;L.OX1=0,L.OY1=1,L.OX2=2,L.OY2=3,L.OX3=4,L.OY3=5,L.OX4=6,L.OY4=7,L.X1=0,L.Y1=1,L.C1R=2,L.C1G=3,L.C1B=4,L.C1A=5,L.U1=6,L.V1=7,L.X2=8,L.Y2=9,L.C2R=10,L.C2G=11,L.C2B=12,L.C2A=13,L.U2=14,L.V2=15,L.X3=16,L.Y3=17,L.C3R=18,L.C3G=19,L.C3B=20,L.C3A=21,L.U3=22,L.V3=23,L.X4=24,L.Y4=25,L.C4R=26,L.C4G=27,L.C4B=28,L.C4A=29,L.U4=30,L.V4=31;class Cn{constructor(t,n){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=n}begin(t){}transform(t,n,s,r){t.x+=A.randomTriangular(-this.jitterX,this.jitterY),t.y+=A.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const Qe=class{constructor(e){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=e}begin(e){this.worldX=e.x+this.centerX,this.worldY=e.y+this.centerY}transform(e,t,n,s){const r=this.angle*A.degreesToRadians,l=e.x-this.worldX,c=e.y-this.worldY,o=Math.sqrt(l*l+c*c);if(o<this.radius){const i=Qe.interpolation.apply(0,r,(this.radius-o)/this.radius),a=Math.cos(i),h=Math.sin(i);e.x=a*l-h*c+this.worldX,e.y=h*l+a*c+this.worldY}}end(){}};let Ke=Qe;Ke.interpolation=new Ue(2);class tt{constructor(t,n,s){if(t==null)throw new Error("name cannot be null.");if(n==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=n,this.timelineIds=[];for(let r=0;r<n.length;r++)this.timelineIds[n[r].getPropertyId()]=!0;this.duration=s}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,n,s,r,l,c,o,i){if(t==null)throw new Error("skeleton cannot be null.");r&&this.duration!=0&&(s%=this.duration,n>0&&(n%=this.duration));const a=this.timelines;for(let h=0,f=a.length;h<f;h++)a[h].apply(t,n,s,l,c,o,i)}static binarySearch(t,n,s=1){let r=0,l=t.length/s-2;if(l==0)return s;let c=l>>>1;for(;;){if(t[(c+1)*s]<=n?r=c+1:l=c,r==l)return(r+1)*s;c=r+l>>>1}}static linearSearch(t,n,s){for(let r=0,l=t.length-s;r<=l;r+=s)if(t[r]>n)return r;return-1}}var Je=(e=>(e[e.rotate=0]="rotate",e[e.translate=1]="translate",e[e.scale=2]="scale",e[e.shear=3]="shear",e[e.attachment=4]="attachment",e[e.color=5]="color",e[e.deform=6]="deform",e[e.event=7]="event",e[e.drawOrder=8]="drawOrder",e[e.ikConstraint=9]="ikConstraint",e[e.transformConstraint=10]="transformConstraint",e[e.pathConstraintPosition=11]="pathConstraintPosition",e[e.pathConstraintSpacing=12]="pathConstraintSpacing",e[e.pathConstraintMix=13]="pathConstraintMix",e[e.twoColor=14]="twoColor",e))(Je||{});const et=class{constructor(e){if(e<=0)throw new Error(`frameCount must be > 0: ${e}`);this.curves=k.newFloatArray((e-1)*et.BEZIER_SIZE)}getFrameCount(){return this.curves.length/et.BEZIER_SIZE+1}setLinear(e){this.curves[e*et.BEZIER_SIZE]=et.LINEAR}setStepped(e){this.curves[e*et.BEZIER_SIZE]=et.STEPPED}getCurveType(e){const t=e*et.BEZIER_SIZE;if(t==this.curves.length)return et.LINEAR;const n=this.curves[t];return n==et.LINEAR?et.LINEAR:n==et.STEPPED?et.STEPPED:et.BEZIER}setCurve(e,t,n,s,r){const l=(-t*2+s)*.03,c=(-n*2+r)*.03,o=((t-s)*3+1)*.006,i=((n-r)*3+1)*.006;let a=l*2+o,h=c*2+i,f=t*.3+l+o*.16666667,d=n*.3+c+i*.16666667,u=e*et.BEZIER_SIZE;const m=this.curves;m[u++]=et.BEZIER;let p=f,g=d;for(let w=u+et.BEZIER_SIZE-1;u<w;u+=2)m[u]=p,m[u+1]=g,f+=a,d+=h,a+=o,h+=i,p+=f,g+=d}getCurvePercent(e,t){t=A.clamp(t,0,1);const n=this.curves;let s=e*et.BEZIER_SIZE;const r=n[s];if(r==et.LINEAR)return t;if(r==et.STEPPED)return 0;s++;let l=0;for(let o=s,i=s+et.BEZIER_SIZE-1;s<i;s+=2)if(l=n[s],l>=t){let a,h;return s==o?(a=0,h=0):(a=n[s-2],h=n[s-1]),h+(n[s+1]-h)*(t-a)/(l-a)}const c=n[s-1];return c+(1-c)*(t-l)/(1-l)}};let pt=et;pt.LINEAR=0,pt.STEPPED=1,pt.BEZIER=2,pt.BEZIER_SIZE=10*2-1;const Dt=class extends pt{constructor(e){super(e),this.frames=k.newFloatArray(e<<1)}getPropertyId(){return(0<<24)+this.boneIndex}setFrame(e,t,n){e<<=1,this.frames[e]=t,this.frames[e+Dt.ROTATION]=n}apply(e,t,n,s,r,l,c){const o=this.frames,i=e.bones[this.boneIndex];if(!i.active)return;if(n<o[0]){switch(l){case C.setup:i.rotation=i.data.rotation;return;case C.first:const m=i.data.rotation-i.rotation;i.rotation+=(m-(16384-(16384.499999999996-m/360|0))*360)*r}return}if(n>=o[o.length-Dt.ENTRIES]){let m=o[o.length+Dt.PREV_ROTATION];switch(l){case C.setup:i.rotation=i.data.rotation+m*r;break;case C.first:case C.replace:m+=i.data.rotation-i.rotation,m-=(16384-(16384.499999999996-m/360|0))*360;case C.add:i.rotation+=m*r}return}const a=tt.binarySearch(o,n,Dt.ENTRIES),h=o[a+Dt.PREV_ROTATION],f=o[a],d=this.getCurvePercent((a>>1)-1,1-(n-f)/(o[a+Dt.PREV_TIME]-f));let u=o[a+Dt.ROTATION]-h;switch(u=h+(u-(16384-(16384.499999999996-u/360|0))*360)*d,l){case C.setup:i.rotation=i.data.rotation+(u-(16384-(16384.499999999996-u/360|0))*360)*r;break;case C.first:case C.replace:u+=i.data.rotation-i.rotation;case C.add:i.rotation+=(u-(16384-(16384.499999999996-u/360|0))*360)*r}}};let at=Dt;at.ENTRIES=2,at.PREV_TIME=-2,at.PREV_ROTATION=-1,at.ROTATION=1;const ct=class extends pt{constructor(e){super(e),this.frames=k.newFloatArray(e*ct.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(e,t,n,s){e*=ct.ENTRIES,this.frames[e]=t,this.frames[e+ct.X]=n,this.frames[e+ct.Y]=s}apply(e,t,n,s,r,l,c){const o=this.frames,i=e.bones[this.boneIndex];if(!i.active)return;if(n<o[0]){switch(l){case C.setup:i.x=i.data.x,i.y=i.data.y;return;case C.first:i.x+=(i.data.x-i.x)*r,i.y+=(i.data.y-i.y)*r}return}let a=0,h=0;if(n>=o[o.length-ct.ENTRIES])a=o[o.length+ct.PREV_X],h=o[o.length+ct.PREV_Y];else{const f=tt.binarySearch(o,n,ct.ENTRIES);a=o[f+ct.PREV_X],h=o[f+ct.PREV_Y];const d=o[f],u=this.getCurvePercent(f/ct.ENTRIES-1,1-(n-d)/(o[f+ct.PREV_TIME]-d));a+=(o[f+ct.X]-a)*u,h+=(o[f+ct.Y]-h)*u}switch(l){case C.setup:i.x=i.data.x+a*r,i.y=i.data.y+h*r;break;case C.first:case C.replace:i.x+=(i.data.x+a-i.x)*r,i.y+=(i.data.y+h-i.y)*r;break;case C.add:i.x+=a*r,i.y+=h*r}}};let bt=ct;bt.ENTRIES=3,bt.PREV_TIME=-3,bt.PREV_X=-2,bt.PREV_Y=-1,bt.X=1,bt.Y=2;class wt extends bt{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,n,s,r,l,c,o){const i=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(s<i[0]){switch(c){case C.setup:a.scaleX=a.data.scaleX,a.scaleY=a.data.scaleY;return;case C.first:a.scaleX+=(a.data.scaleX-a.scaleX)*l,a.scaleY+=(a.data.scaleY-a.scaleY)*l}return}let h=0,f=0;if(s>=i[i.length-wt.ENTRIES])h=i[i.length+wt.PREV_X]*a.data.scaleX,f=i[i.length+wt.PREV_Y]*a.data.scaleY;else{const d=tt.binarySearch(i,s,wt.ENTRIES);h=i[d+wt.PREV_X],f=i[d+wt.PREV_Y];const u=i[d],m=this.getCurvePercent(d/wt.ENTRIES-1,1-(s-u)/(i[d+wt.PREV_TIME]-u));h=(h+(i[d+wt.X]-h)*m)*a.data.scaleX,f=(f+(i[d+wt.Y]-f)*m)*a.data.scaleY}if(l==1)c==C.add?(a.scaleX+=h-a.data.scaleX,a.scaleY+=f-a.data.scaleY):(a.scaleX=h,a.scaleY=f);else{let d=0,u=0;if(o==lt.mixOut)switch(c){case C.setup:d=a.data.scaleX,u=a.data.scaleY,a.scaleX=d+(Math.abs(h)*A.signum(d)-d)*l,a.scaleY=u+(Math.abs(f)*A.signum(u)-u)*l;break;case C.first:case C.replace:d=a.scaleX,u=a.scaleY,a.scaleX=d+(Math.abs(h)*A.signum(d)-d)*l,a.scaleY=u+(Math.abs(f)*A.signum(u)-u)*l;break;case C.add:d=a.scaleX,u=a.scaleY,a.scaleX=d+(Math.abs(h)*A.signum(d)-a.data.scaleX)*l,a.scaleY=u+(Math.abs(f)*A.signum(u)-a.data.scaleY)*l}else switch(c){case C.setup:d=Math.abs(a.data.scaleX)*A.signum(h),u=Math.abs(a.data.scaleY)*A.signum(f),a.scaleX=d+(h-d)*l,a.scaleY=u+(f-u)*l;break;case C.first:case C.replace:d=Math.abs(a.scaleX)*A.signum(h),u=Math.abs(a.scaleY)*A.signum(f),a.scaleX=d+(h-d)*l,a.scaleY=u+(f-u)*l;break;case C.add:d=A.signum(h),u=A.signum(f),a.scaleX=Math.abs(a.scaleX)*d+(h-Math.abs(a.data.scaleX)*d)*l,a.scaleY=Math.abs(a.scaleY)*u+(f-Math.abs(a.data.scaleY)*u)*l}}}}class xt extends bt{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,n,s,r,l,c,o){const i=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(s<i[0]){switch(c){case C.setup:a.shearX=a.data.shearX,a.shearY=a.data.shearY;return;case C.first:a.shearX+=(a.data.shearX-a.shearX)*l,a.shearY+=(a.data.shearY-a.shearY)*l}return}let h=0,f=0;if(s>=i[i.length-xt.ENTRIES])h=i[i.length+xt.PREV_X],f=i[i.length+xt.PREV_Y];else{const d=tt.binarySearch(i,s,xt.ENTRIES);h=i[d+xt.PREV_X],f=i[d+xt.PREV_Y];const u=i[d],m=this.getCurvePercent(d/xt.ENTRIES-1,1-(s-u)/(i[d+xt.PREV_TIME]-u));h=h+(i[d+xt.X]-h)*m,f=f+(i[d+xt.Y]-f)*m}switch(c){case C.setup:a.shearX=a.data.shearX+h*l,a.shearY=a.data.shearY+f*l;break;case C.first:case C.replace:a.shearX+=(a.data.shearX+h-a.shearX)*l,a.shearY+=(a.data.shearY+f-a.shearY)*l;break;case C.add:a.shearX+=h*l,a.shearY+=f*l}}}const Z=class extends pt{constructor(e){super(e),this.frames=k.newFloatArray(e*Z.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(e,t,n,s,r,l){e*=Z.ENTRIES,this.frames[e]=t,this.frames[e+Z.R]=n,this.frames[e+Z.G]=s,this.frames[e+Z.B]=r,this.frames[e+Z.A]=l}apply(e,t,n,s,r,l,c){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const i=this.frames;if(n<i[0]){switch(l){case C.setup:o.color.setFromColor(o.data.color);return;case C.first:const u=o.color,m=o.data.color;u.add((m.r-u.r)*r,(m.g-u.g)*r,(m.b-u.b)*r,(m.a-u.a)*r)}return}let a=0,h=0,f=0,d=0;if(n>=i[i.length-Z.ENTRIES]){const u=i.length;a=i[u+Z.PREV_R],h=i[u+Z.PREV_G],f=i[u+Z.PREV_B],d=i[u+Z.PREV_A]}else{const u=tt.binarySearch(i,n,Z.ENTRIES);a=i[u+Z.PREV_R],h=i[u+Z.PREV_G],f=i[u+Z.PREV_B],d=i[u+Z.PREV_A];const m=i[u],p=this.getCurvePercent(u/Z.ENTRIES-1,1-(n-m)/(i[u+Z.PREV_TIME]-m));a+=(i[u+Z.R]-a)*p,h+=(i[u+Z.G]-h)*p,f+=(i[u+Z.B]-f)*p,d+=(i[u+Z.A]-d)*p}if(r==1)o.color.set(a,h,f,d);else{const u=o.color;l==C.setup&&u.setFromColor(o.data.color),u.add((a-u.r)*r,(h-u.g)*r,(f-u.b)*r,(d-u.a)*r)}}};let dt=Z;dt.ENTRIES=5,dt.PREV_TIME=-5,dt.PREV_R=-4,dt.PREV_G=-3,dt.PREV_B=-2,dt.PREV_A=-1,dt.R=1,dt.G=2,dt.B=3,dt.A=4;const U=class extends pt{constructor(e){super(e),this.frames=k.newFloatArray(e*U.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(e,t,n,s,r,l,c,o,i){e*=U.ENTRIES,this.frames[e]=t,this.frames[e+U.R]=n,this.frames[e+U.G]=s,this.frames[e+U.B]=r,this.frames[e+U.A]=l,this.frames[e+U.R2]=c,this.frames[e+U.G2]=o,this.frames[e+U.B2]=i}apply(e,t,n,s,r,l,c){const o=e.slots[this.slotIndex];if(!o.bone.active)return;const i=this.frames;if(n<i[0]){switch(l){case C.setup:o.color.setFromColor(o.data.color),o.darkColor.setFromColor(o.data.darkColor);return;case C.first:const g=o.color,w=o.darkColor,S=o.data.color,E=o.data.darkColor;g.add((S.r-g.r)*r,(S.g-g.g)*r,(S.b-g.b)*r,(S.a-g.a)*r),w.add((E.r-w.r)*r,(E.g-w.g)*r,(E.b-w.b)*r,0)}return}let a=0,h=0,f=0,d=0,u=0,m=0,p=0;if(n>=i[i.length-U.ENTRIES]){const g=i.length;a=i[g+U.PREV_R],h=i[g+U.PREV_G],f=i[g+U.PREV_B],d=i[g+U.PREV_A],u=i[g+U.PREV_R2],m=i[g+U.PREV_G2],p=i[g+U.PREV_B2]}else{const g=tt.binarySearch(i,n,U.ENTRIES);a=i[g+U.PREV_R],h=i[g+U.PREV_G],f=i[g+U.PREV_B],d=i[g+U.PREV_A],u=i[g+U.PREV_R2],m=i[g+U.PREV_G2],p=i[g+U.PREV_B2];const w=i[g],S=this.getCurvePercent(g/U.ENTRIES-1,1-(n-w)/(i[g+U.PREV_TIME]-w));a+=(i[g+U.R]-a)*S,h+=(i[g+U.G]-h)*S,f+=(i[g+U.B]-f)*S,d+=(i[g+U.A]-d)*S,u+=(i[g+U.R2]-u)*S,m+=(i[g+U.G2]-m)*S,p+=(i[g+U.B2]-p)*S}if(r==1)o.color.set(a,h,f,d),o.darkColor.set(u,m,p,1);else{const g=o.color,w=o.darkColor;l==C.setup&&(g.setFromColor(o.data.color),w.setFromColor(o.data.darkColor)),g.add((a-g.r)*r,(h-g.g)*r,(f-g.b)*r,(d-g.a)*r),w.add((u-w.r)*r,(m-w.g)*r,(p-w.b)*r,0)}}};let nt=U;nt.ENTRIES=8,nt.PREV_TIME=-8,nt.PREV_R=-7,nt.PREV_G=-6,nt.PREV_B=-5,nt.PREV_A=-4,nt.PREV_R2=-3,nt.PREV_G2=-2,nt.PREV_B2=-1,nt.R=1,nt.G=2,nt.B=3,nt.A=4,nt.R2=5,nt.G2=6,nt.B2=7;class Ht{constructor(t){this.frames=k.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,n,s){this.frames[t]=n,this.attachmentNames[t]=s}apply(t,n,s,r,l,c,o){const i=t.slots[this.slotIndex];if(!i.bone.active)return;if(o==lt.mixOut){c==C.setup&&this.setAttachment(t,i,i.data.attachmentName);return}const a=this.frames;if(s<a[0]){(c==C.setup||c==C.first)&&this.setAttachment(t,i,i.data.attachmentName);return}let h=0;s>=a[a.length-1]?h=a.length-1:h=tt.binarySearch(a,s,1)-1;const f=this.attachmentNames[h];t.slots[this.slotIndex].setAttachment(f==null?null:t.getAttachment(this.slotIndex,f))}setAttachment(t,n,s){n.setAttachment(s==null?null:t.getAttachment(this.slotIndex,s))}}let tn=null;class be extends pt{constructor(t){super(t),this.frames=k.newFloatArray(t),this.frameVertices=new Array(t),tn==null&&(tn=k.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,n,s){this.frames[t]=n,this.frameVertices[t]=s}apply(t,n,s,r,l,c,o){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.getAttachment();if(!(a instanceof _t)||a.deformAttachment!=this.attachment)return;const h=i.deform;h.length==0&&(c=C.setup);const f=this.frameVertices,d=f[0].length,u=this.frames;if(s<u[0]){const x=a;switch(c){case C.setup:h.length=0;return;case C.first:if(l==1){h.length=0;break}const y=k.setArraySize(h,d);if(x.bones==null){const b=x.vertices;for(let M=0;M<d;M++)y[M]+=(b[M]-y[M])*l}else{l=1-l;for(let b=0;b<d;b++)y[b]*=l}}return}const m=k.setArraySize(h,d);if(s>=u[u.length-1]){const x=f[u.length-1];if(l==1)if(c==C.add){const y=a;if(y.bones==null){const b=y.vertices;for(let M=0;M<d;M++)m[M]+=x[M]-b[M]}else for(let b=0;b<d;b++)m[b]+=x[b]}else k.arrayCopy(x,0,m,0,d);else switch(c){case C.setup:{const b=a;if(b.bones==null){const M=b.vertices;for(let T=0;T<d;T++){const R=M[T];m[T]=R+(x[T]-R)*l}}else for(let M=0;M<d;M++)m[M]=x[M]*l;break}case C.first:case C.replace:for(let b=0;b<d;b++)m[b]+=(x[b]-m[b])*l;break;case C.add:const y=a;if(y.bones==null){const b=y.vertices;for(let M=0;M<d;M++)m[M]+=(x[M]-b[M])*l}else for(let b=0;b<d;b++)m[b]+=x[b]*l}return}const p=tt.binarySearch(u,s),g=f[p-1],w=f[p],S=u[p],E=this.getCurvePercent(p-1,1-(s-S)/(u[p-1]-S));if(l==1)if(c==C.add){const x=a;if(x.bones==null){const y=x.vertices;for(let b=0;b<d;b++){const M=g[b];m[b]+=M+(w[b]-M)*E-y[b]}}else for(let y=0;y<d;y++){const b=g[y];m[y]+=b+(w[y]-b)*E}}else for(let x=0;x<d;x++){const y=g[x];m[x]=y+(w[x]-y)*E}else switch(c){case C.setup:{const y=a;if(y.bones==null){const b=y.vertices;for(let M=0;M<d;M++){const T=g[M],R=b[M];m[M]=R+(T+(w[M]-T)*E-R)*l}}else for(let b=0;b<d;b++){const M=g[b];m[b]=(M+(w[b]-M)*E)*l}break}case C.first:case C.replace:for(let y=0;y<d;y++){const b=g[y];m[y]+=(b+(w[y]-b)*E-m[y])*l}break;case C.add:const x=a;if(x.bones==null){const y=x.vertices;for(let b=0;b<d;b++){const M=g[b];m[b]+=(M+(w[b]-M)*E-y[b])*l}}else for(let y=0;y<d;y++){const b=g[y];m[y]+=(b+(w[y]-b)*E)*l}}}}class oe{constructor(t){this.frames=k.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,n){this.frames[t]=n.time,this.events[t]=n}apply(t,n,s,r,l,c,o){if(r==null)return;const i=this.frames,a=this.frames.length;if(n>s)this.apply(t,n,Number.MAX_VALUE,r,l,c,o),n=-1;else if(n>=i[a-1])return;if(s<i[0])return;let h=0;if(n<i[0])h=0;else{h=tt.binarySearch(i,n);const f=i[h];for(;h>0&&i[h-1]==f;)h--}for(;h<a&&s>=i[h];h++)r.push(this.events[h])}}class jt{constructor(t){this.frames=k.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,n,s){this.frames[t]=n,this.drawOrders[t]=s}apply(t,n,s,r,l,c,o){const i=t.drawOrder,a=t.slots;if(o==lt.mixOut&&c==C.setup){k.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const h=this.frames;if(s<h[0]){(c==C.setup||c==C.first)&&k.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let f=0;s>=h[h.length-1]?f=h.length-1:f=tt.binarySearch(h,s)-1;const d=this.drawOrders[f];if(d==null)k.arrayCopy(a,0,i,0,a.length);else for(let u=0,m=d.length;u<m;u++)i[u]=a[d[u]]}}const q=class extends pt{constructor(e){super(e),this.frames=k.newFloatArray(e*q.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(e,t,n,s,r,l,c){e*=q.ENTRIES,this.frames[e]=t,this.frames[e+q.MIX]=n,this.frames[e+q.SOFTNESS]=s,this.frames[e+q.BEND_DIRECTION]=r,this.frames[e+q.COMPRESS]=l?1:0,this.frames[e+q.STRETCH]=c?1:0}apply(e,t,n,s,r,l,c){const o=this.frames,i=e.ikConstraints[this.ikConstraintIndex];if(!i.active)return;if(n<o[0]){switch(l){case C.setup:i.mix=i.data.mix,i.softness=i.data.softness,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch;return;case C.first:i.mix+=(i.data.mix-i.mix)*r,i.softness+=(i.data.softness-i.softness)*r,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch}return}if(n>=o[o.length-q.ENTRIES]){l==C.setup?(i.mix=i.data.mix+(o[o.length+q.PREV_MIX]-i.data.mix)*r,i.softness=i.data.softness+(o[o.length+q.PREV_SOFTNESS]-i.data.softness)*r,c==lt.mixOut?(i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch):(i.bendDirection=o[o.length+q.PREV_BEND_DIRECTION],i.compress=o[o.length+q.PREV_COMPRESS]!=0,i.stretch=o[o.length+q.PREV_STRETCH]!=0)):(i.mix+=(o[o.length+q.PREV_MIX]-i.mix)*r,i.softness+=(o[o.length+q.PREV_SOFTNESS]-i.softness)*r,c==lt.mixIn&&(i.bendDirection=o[o.length+q.PREV_BEND_DIRECTION],i.compress=o[o.length+q.PREV_COMPRESS]!=0,i.stretch=o[o.length+q.PREV_STRETCH]!=0));return}const a=tt.binarySearch(o,n,q.ENTRIES),h=o[a+q.PREV_MIX],f=o[a+q.PREV_SOFTNESS],d=o[a],u=this.getCurvePercent(a/q.ENTRIES-1,1-(n-d)/(o[a+q.PREV_TIME]-d));l==C.setup?(i.mix=i.data.mix+(h+(o[a+q.MIX]-h)*u-i.data.mix)*r,i.softness=i.data.softness+(f+(o[a+q.SOFTNESS]-f)*u-i.data.softness)*r,c==lt.mixOut?(i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch):(i.bendDirection=o[a+q.PREV_BEND_DIRECTION],i.compress=o[a+q.PREV_COMPRESS]!=0,i.stretch=o[a+q.PREV_STRETCH]!=0)):(i.mix+=(h+(o[a+q.MIX]-h)*u-i.mix)*r,i.softness+=(f+(o[a+q.SOFTNESS]-f)*u-i.softness)*r,c==lt.mixIn&&(i.bendDirection=o[a+q.PREV_BEND_DIRECTION],i.compress=o[a+q.PREV_COMPRESS]!=0,i.stretch=o[a+q.PREV_STRETCH]!=0))}};let ot=q;ot.ENTRIES=6,ot.PREV_TIME=-6,ot.PREV_MIX=-5,ot.PREV_SOFTNESS=-4,ot.PREV_BEND_DIRECTION=-3,ot.PREV_COMPRESS=-2,ot.PREV_STRETCH=-1,ot.MIX=1,ot.SOFTNESS=2,ot.BEND_DIRECTION=3,ot.COMPRESS=4,ot.STRETCH=5;const j=class extends pt{constructor(e){super(e),this.frames=k.newFloatArray(e*j.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(e,t,n,s,r,l){e*=j.ENTRIES,this.frames[e]=t,this.frames[e+j.ROTATE]=n,this.frames[e+j.TRANSLATE]=s,this.frames[e+j.SCALE]=r,this.frames[e+j.SHEAR]=l}apply(e,t,n,s,r,l,c){const o=this.frames,i=e.transformConstraints[this.transformConstraintIndex];if(!i.active)return;if(n<o[0]){const u=i.data;switch(l){case C.setup:i.rotateMix=u.rotateMix,i.translateMix=u.translateMix,i.scaleMix=u.scaleMix,i.shearMix=u.shearMix;return;case C.first:i.rotateMix+=(u.rotateMix-i.rotateMix)*r,i.translateMix+=(u.translateMix-i.translateMix)*r,i.scaleMix+=(u.scaleMix-i.scaleMix)*r,i.shearMix+=(u.shearMix-i.shearMix)*r}return}let a=0,h=0,f=0,d=0;if(n>=o[o.length-j.ENTRIES]){const u=o.length;a=o[u+j.PREV_ROTATE],h=o[u+j.PREV_TRANSLATE],f=o[u+j.PREV_SCALE],d=o[u+j.PREV_SHEAR]}else{const u=tt.binarySearch(o,n,j.ENTRIES);a=o[u+j.PREV_ROTATE],h=o[u+j.PREV_TRANSLATE],f=o[u+j.PREV_SCALE],d=o[u+j.PREV_SHEAR];const m=o[u],p=this.getCurvePercent(u/j.ENTRIES-1,1-(n-m)/(o[u+j.PREV_TIME]-m));a+=(o[u+j.ROTATE]-a)*p,h+=(o[u+j.TRANSLATE]-h)*p,f+=(o[u+j.SCALE]-f)*p,d+=(o[u+j.SHEAR]-d)*p}if(l==C.setup){const u=i.data;i.rotateMix=u.rotateMix+(a-u.rotateMix)*r,i.translateMix=u.translateMix+(h-u.translateMix)*r,i.scaleMix=u.scaleMix+(f-u.scaleMix)*r,i.shearMix=u.shearMix+(d-u.shearMix)*r}else i.rotateMix+=(a-i.rotateMix)*r,i.translateMix+=(h-i.translateMix)*r,i.scaleMix+=(f-i.scaleMix)*r,i.shearMix+=(d-i.shearMix)*r}};let ut=j;ut.ENTRIES=5,ut.PREV_TIME=-5,ut.PREV_ROTATE=-4,ut.PREV_TRANSLATE=-3,ut.PREV_SCALE=-2,ut.PREV_SHEAR=-1,ut.ROTATE=1,ut.TRANSLATE=2,ut.SCALE=3,ut.SHEAR=4;const Tt=class extends pt{constructor(e){super(e),this.frames=k.newFloatArray(e*Tt.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(e,t,n){e*=Tt.ENTRIES,this.frames[e]=t,this.frames[e+Tt.VALUE]=n}apply(e,t,n,s,r,l,c){const o=this.frames,i=e.pathConstraints[this.pathConstraintIndex];if(!i.active)return;if(n<o[0]){switch(l){case C.setup:i.position=i.data.position;return;case C.first:i.position+=(i.data.position-i.position)*r}return}let a=0;if(n>=o[o.length-Tt.ENTRIES])a=o[o.length+Tt.PREV_VALUE];else{const h=tt.binarySearch(o,n,Tt.ENTRIES);a=o[h+Tt.PREV_VALUE];const f=o[h],d=this.getCurvePercent(h/Tt.ENTRIES-1,1-(n-f)/(o[h+Tt.PREV_TIME]-f));a+=(o[h+Tt.VALUE]-a)*d}l==C.setup?i.position=i.data.position+(a-i.data.position)*r:i.position+=(a-i.position)*r}};let vt=Tt;vt.ENTRIES=2,vt.PREV_TIME=-2,vt.PREV_VALUE=-1,vt.VALUE=1;class kt extends vt{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,n,s,r,l,c,o){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<i[0]){switch(c){case C.setup:a.spacing=a.data.spacing;return;case C.first:a.spacing+=(a.data.spacing-a.spacing)*l}return}let h=0;if(s>=i[i.length-kt.ENTRIES])h=i[i.length+kt.PREV_VALUE];else{const f=tt.binarySearch(i,s,kt.ENTRIES);h=i[f+kt.PREV_VALUE];const d=i[f],u=this.getCurvePercent(f/kt.ENTRIES-1,1-(s-d)/(i[f+kt.PREV_TIME]-d));h+=(i[f+kt.VALUE]-h)*u}c==C.setup?a.spacing=a.data.spacing+(h-a.data.spacing)*l:a.spacing+=(h-a.spacing)*l}}const ft=class extends pt{constructor(e){super(e),this.frames=k.newFloatArray(e*ft.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(e,t,n,s){e*=ft.ENTRIES,this.frames[e]=t,this.frames[e+ft.ROTATE]=n,this.frames[e+ft.TRANSLATE]=s}apply(e,t,n,s,r,l,c){const o=this.frames,i=e.pathConstraints[this.pathConstraintIndex];if(!i.active)return;if(n<o[0]){switch(l){case C.setup:i.rotateMix=i.data.rotateMix,i.translateMix=i.data.translateMix;return;case C.first:i.rotateMix+=(i.data.rotateMix-i.rotateMix)*r,i.translateMix+=(i.data.translateMix-i.translateMix)*r}return}let a=0,h=0;if(n>=o[o.length-ft.ENTRIES])a=o[o.length+ft.PREV_ROTATE],h=o[o.length+ft.PREV_TRANSLATE];else{const f=tt.binarySearch(o,n,ft.ENTRIES);a=o[f+ft.PREV_ROTATE],h=o[f+ft.PREV_TRANSLATE];const d=o[f],u=this.getCurvePercent(f/ft.ENTRIES-1,1-(n-d)/(o[f+ft.PREV_TIME]-d));a+=(o[f+ft.ROTATE]-a)*u,h+=(o[f+ft.TRANSLATE]-h)*u}l==C.setup?(i.rotateMix=i.data.rotateMix+(a-i.data.rotateMix)*r,i.translateMix=i.data.translateMix+(h-i.data.translateMix)*r):(i.rotateMix+=(a-i.rotateMix)*r,i.translateMix+=(h-i.translateMix)*r)}};let Pt=ft;Pt.ENTRIES=3,Pt.PREV_TIME=-3,Pt.PREV_ROTATE=-2,Pt.PREV_TRANSLATE=-1,Pt.ROTATE=1,Pt.TRANSLATE=2;const Q=class{constructor(e){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new ye(this),this.propertyIDs=new Xe,this.animationsChanged=!1,this.trackEntryPool=new we(()=>new le),this.data=e}update(e){e*=this.timeScale;const t=this.tracks;for(let n=0,s=t.length;n<s;n++){const r=t[n];if(r==null)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let l=e*r.timeScale;if(r.delay>0){if(r.delay-=l,r.delay>0)continue;l=-r.delay,r.delay=0}let c=r.next;if(c!=null){const o=r.trackLast-c.delay;if(o>=0){for(c.delay=0,c.trackTime+=r.timeScale==0?0:(o/r.timeScale+e)*c.timeScale,r.trackTime+=l,this.setCurrent(n,c,!0);c.mixingFrom!=null;)c.mixTime+=e,c=c.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&r.mixingFrom==null){t[n]=null,this.queue.end(r),this.disposeNext(r);continue}if(r.mixingFrom!=null&&this.updateMixingFrom(r,e)){let o=r.mixingFrom;for(r.mixingFrom=null,o!=null&&(o.mixingTo=null);o!=null;)this.queue.end(o),o=o.mixingFrom}r.trackTime+=l}this.queue.drain()}updateMixingFrom(e,t){const n=e.mixingFrom;if(n==null)return!0;const s=this.updateMixingFrom(n,t);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,e.mixTime>0&&e.mixTime>=e.mixDuration?((n.totalAlpha==0||e.mixDuration==0)&&(e.mixingFrom=n.mixingFrom,n.mixingFrom!=null&&(n.mixingFrom.mixingTo=e),e.interruptAlpha=n.interruptAlpha,this.queue.end(n)),s):(n.trackTime+=t*n.timeScale,e.mixTime+=t,!1)}apply(e){if(e==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,n=this.tracks;let s=!1;for(let c=0,o=n.length;c<o;c++){const i=n[c];if(i==null||i.delay>0)continue;s=!0;const a=c==0?C.first:i.mixBlend;let h=i.alpha;i.mixingFrom!=null?h*=this.applyMixingFrom(i,e,a):i.trackTime>=i.trackEnd&&i.next==null&&(h=0);const f=i.animationLast,d=i.getAnimationTime(),u=i.animation.timelines.length,m=i.animation.timelines;if(c==0&&h==1||a==C.add)for(let p=0;p<u;p++){k.webkit602BugfixHelper(h,a);const g=m[p];g instanceof Ht?this.applyAttachmentTimeline(g,e,d,a,!0):g.apply(e,f,d,t,h,a,lt.mixIn)}else{const p=i.timelineMode,g=i.timelinesRotation.length==0;g&&k.setArraySize(i.timelinesRotation,u<<1,null);const w=i.timelinesRotation;for(let S=0;S<u;S++){const E=m[S],x=p[S]==Q.SUBSEQUENT?a:C.setup;E instanceof at?this.applyRotateTimeline(E,e,d,h,x,w,S<<1,g):E instanceof Ht?this.applyAttachmentTimeline(E,e,d,a,!0):(k.webkit602BugfixHelper(h,a),E.apply(e,f,d,t,h,x,lt.mixIn))}}this.queueEvents(i,d),t.length=0,i.nextAnimationLast=d,i.nextTrackLast=i.trackTime}const r=this.unkeyedState+Q.SETUP,l=e.slots;for(let c=0,o=e.slots.length;c<o;c++){const i=l[c];if(i.attachmentState==r){const a=i.data.attachmentName;i.setAttachment(a==null?null:e.getAttachment(i.data.index,a))}}return this.unkeyedState+=2,this.queue.drain(),s}applyMixingFrom(e,t,n){const s=e.mixingFrom;s.mixingFrom!=null&&this.applyMixingFrom(s,t,n);let r=0;e.mixDuration==0?(r=1,n==C.first&&(n=C.setup)):(r=e.mixTime/e.mixDuration,r>1&&(r=1),n!=C.first&&(n=s.mixBlend));const l=r<s.eventThreshold?this.events:null,c=r<s.attachmentThreshold,o=r<s.drawOrderThreshold,i=s.animationLast,a=s.getAnimationTime(),h=s.animation.timelines.length,f=s.animation.timelines,d=s.alpha*e.interruptAlpha,u=d*(1-r);if(n==C.add)for(let m=0;m<h;m++)f[m].apply(t,i,a,l,u,n,lt.mixOut);else{const m=s.timelineMode,p=s.timelineHoldMix,g=s.timelinesRotation.length==0;g&&k.setArraySize(s.timelinesRotation,h<<1,null);const w=s.timelinesRotation;s.totalAlpha=0;for(let S=0;S<h;S++){const E=f[S];let x=lt.mixOut,y,b=0;switch(m[S]){case Q.SUBSEQUENT:if(!o&&E instanceof jt)continue;y=n,b=u;break;case Q.FIRST:y=C.setup,b=u;break;case Q.HOLD_SUBSEQUENT:y=n,b=d;break;case Q.HOLD_FIRST:y=C.setup,b=d;break;default:y=C.setup;const M=p[S];b=d*Math.max(0,1-M.mixTime/M.mixDuration);break}s.totalAlpha+=b,E instanceof at?this.applyRotateTimeline(E,t,a,b,y,w,S<<1,g):E instanceof Ht?this.applyAttachmentTimeline(E,t,a,y,c):(k.webkit602BugfixHelper(b,n),o&&E instanceof jt&&y==C.setup&&(x=lt.mixIn),E.apply(t,i,a,l,b,y,x))}}return e.mixDuration>0&&this.queueEvents(s,a),this.events.length=0,s.nextAnimationLast=a,s.nextTrackLast=s.trackTime,r}applyAttachmentTimeline(e,t,n,s,r){const l=t.slots[e.slotIndex];if(!l.bone.active)return;const c=e.frames;if(n<c[0])(s==C.setup||s==C.first)&&this.setAttachment(t,l,l.data.attachmentName,r);else{let o;n>=c[c.length-1]?o=c.length-1:o=tt.binarySearch(c,n)-1,this.setAttachment(t,l,e.attachmentNames[o],r)}l.attachmentState<=this.unkeyedState&&(l.attachmentState=this.unkeyedState+Q.SETUP)}setAttachment(e,t,n,s){t.setAttachment(n==null?null:e.getAttachment(t.data.index,n)),s&&(t.attachmentState=this.unkeyedState+Q.CURRENT)}applyRotateTimeline(e,t,n,s,r,l,c,o){if(o&&(l[c]=0),s==1){e.apply(t,0,n,null,1,r,lt.mixIn);return}const i=e,a=i.frames,h=t.bones[i.boneIndex];if(!h.active)return;let f=0,d=0;if(n<a[0])switch(r){case C.setup:h.rotation=h.data.rotation;default:return;case C.first:f=h.rotation,d=h.data.rotation}else if(f=r==C.setup?h.data.rotation:h.rotation,n>=a[a.length-at.ENTRIES])d=h.data.rotation+a[a.length+at.PREV_ROTATION];else{const p=tt.binarySearch(a,n,at.ENTRIES),g=a[p+at.PREV_ROTATION],w=a[p],S=i.getCurvePercent((p>>1)-1,1-(n-w)/(a[p+at.PREV_TIME]-w));d=a[p+at.ROTATION]-g,d-=(16384-(16384.499999999996-d/360|0))*360,d=g+d*S+h.data.rotation,d-=(16384-(16384.499999999996-d/360|0))*360}let u=0,m=d-f;if(m-=(16384-(16384.499999999996-m/360|0))*360,m==0)u=l[c];else{let p=0,g=0;o?(p=0,g=m):(p=l[c],g=l[c+1]);const w=m>0;let S=p>=0;A.signum(g)!=A.signum(m)&&Math.abs(g)<=90&&(Math.abs(p)>180&&(p+=360*A.signum(p)),S=w),u=m+p-p%360,S!=w&&(u+=360*A.signum(p)),l[c]=u}l[c+1]=m,f+=u*s,h.rotation=f-(16384-(16384.499999999996-f/360|0))*360}queueEvents(e,t){const n=e.animationStart,s=e.animationEnd,r=s-n,l=e.trackLast%r,c=this.events;let o=0;const i=c.length;for(;o<i;o++){const h=c[o];if(h.time<l)break;h.time>s||this.queue.event(e,h)}let a=!1;for(e.loop?a=r==0||l>e.trackTime%r:a=t>=s&&e.animationLast<s,a&&this.queue.complete(e);o<i;o++)c[o].time<n||this.queue.event(e,c[o])}clearTracks(){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,n=this.tracks.length;t<n;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=e,this.queue.drain()}clearTrack(e){if(e>=this.tracks.length)return;const t=this.tracks[e];if(t==null)return;this.queue.end(t),this.disposeNext(t);let n=t;for(;;){const s=n.mixingFrom;if(s==null)break;this.queue.end(s),n.mixingFrom=null,n.mixingTo=null,n=s}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(e,t,n){const s=this.expandToIndex(e);this.tracks[e]=t,s!=null&&(n&&this.queue.interrupt(s),t.mixingFrom=s,s.mixingTo=t,t.mixTime=0,s.mixingFrom!=null&&s.mixDuration>0&&(t.interruptAlpha*=Math.min(1,s.mixTime/s.mixDuration)),s.timelinesRotation.length=0),this.queue.start(t)}setAnimation(e,t,n){const s=this.data.skeletonData.findAnimation(t);if(s==null)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(e,s,n)}setAnimationWith(e,t,n){if(t==null)throw new Error("animation cannot be null.");let s=!0,r=this.expandToIndex(e);r!=null&&(r.nextTrackLast==-1?(this.tracks[e]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.disposeNext(r),r=r.mixingFrom,s=!1):this.disposeNext(r));const l=this.trackEntry(e,t,n,r);return this.setCurrent(e,l,s),this.queue.drain(),l}addAnimation(e,t,n,s){const r=this.data.skeletonData.findAnimation(t);if(r==null)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(e,r,n,s)}addAnimationWith(e,t,n,s){if(t==null)throw new Error("animation cannot be null.");let r=this.expandToIndex(e);if(r!=null)for(;r.next!=null;)r=r.next;const l=this.trackEntry(e,t,n,r);if(r==null)this.setCurrent(e,l,!0),this.queue.drain();else if(r.next=l,s<=0){const c=r.animationEnd-r.animationStart;c!=0?(r.loop?s+=c*(1+(r.trackTime/c|0)):s+=Math.max(c,r.trackTime),s-=this.data.getMix(r.animation,t)):s=r.trackTime}return l.delay=s,l}setEmptyAnimation(e,t){const n=this.setAnimationWith(e,Q.emptyAnimation,!1);return n.mixDuration=t,n.trackEnd=t,n}addEmptyAnimation(e,t,n){n<=0&&(n-=t);const s=this.addAnimationWith(e,Q.emptyAnimation,!1,n);return s.mixDuration=t,s.trackEnd=t,s}setEmptyAnimations(e){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,s=this.tracks.length;n<s;n++){const r=this.tracks[n];r!=null&&this.setEmptyAnimation(r.trackIndex,e)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(e){return e<this.tracks.length?this.tracks[e]:(k.ensureArrayCapacity(this.tracks,e+1,null),this.tracks.length=e+1,null)}trackEntry(e,t,n,s){const r=this.trackEntryPool.obtain();return r.trackIndex=e,r.animation=t,r.loop=n,r.holdPrevious=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=t.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.interruptAlpha=1,r.mixTime=0,r.mixDuration=s==null?0:this.data.getMix(s.animation,t),r.mixBlend=C.replace,r}disposeNext(e){let t=e.next;for(;t!=null;)this.queue.dispose(t),t=t.next;e.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let e=0,t=this.tracks.length;e<t;e++){let n=this.tracks[e];if(n!=null){for(;n.mixingFrom!=null;)n=n.mixingFrom;do(n.mixingFrom==null||n.mixBlend!=C.add)&&this.computeHold(n),n=n.mixingTo;while(n!=null)}}}computeHold(e){const t=e.mixingTo,n=e.animation.timelines,s=e.animation.timelines.length,r=k.setArraySize(e.timelineMode,s);e.timelineHoldMix.length=0;const l=k.setArraySize(e.timelineHoldMix,s),c=this.propertyIDs;if(t!=null&&t.holdPrevious){for(let o=0;o<s;o++)r[o]=c.add(n[o].getPropertyId())?Q.HOLD_FIRST:Q.HOLD_SUBSEQUENT;return}t:for(let o=0;o<s;o++){const i=n[o],a=i.getPropertyId();if(!c.add(a))r[o]=Q.SUBSEQUENT;else if(t==null||i instanceof Ht||i instanceof jt||i instanceof oe||!t.animation.hasTimeline(a))r[o]=Q.FIRST;else{for(let h=t.mixingTo;h!=null;h=h.mixingTo)if(!h.animation.hasTimeline(a)){if(e.mixDuration>0){r[o]=Q.HOLD_MIX,l[o]=h;continue t}break}r[o]=Q.HOLD_FIRST}}}getCurrent(e){return e>=this.tracks.length?null:this.tracks[e]}addListener(e){if(e==null)throw new Error("listener cannot be null.");this.listeners.push(e)}removeListener(e){const t=this.listeners.indexOf(e);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(e,t,n){Q.deprecatedWarning1||(Q.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(e,t,n)}addAnimationByName(e,t,n,s){Q.deprecatedWarning2||(Q.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(e,t,n,s)}hasAnimation(e){return this.data.skeletonData.findAnimation(e)!==null}hasAnimationByName(e){return Q.deprecatedWarning3||(Q.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(e)}};let Mt=Q;Mt.emptyAnimation=new tt("<empty>",[],0),Mt.SUBSEQUENT=0,Mt.FIRST=1,Mt.HOLD_SUBSEQUENT=2,Mt.HOLD_FIRST=3,Mt.HOLD_MIX=4,Mt.SETUP=1,Mt.CURRENT=2,Mt.deprecatedWarning1=!1,Mt.deprecatedWarning2=!1,Mt.deprecatedWarning3=!1;const Nt=class{constructor(){this.mixBlend=C.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const e=this.animationEnd-this.animationStart;return e==0?this.animationStart:this.trackTime%e+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(e){this.animationLast=e,this.nextAnimationLast=e}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return Nt.deprecatedWarning1||(Nt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(e){Nt.deprecatedWarning1||(Nt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=e}get endTime(){return Nt.deprecatedWarning2||(Nt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(e){Nt.deprecatedWarning2||(Nt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=e}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let le=Nt;le.deprecatedWarning1=!1,le.deprecatedWarning2=!1;const Me=class{constructor(e){this.objects=[],this.drainDisabled=!1,this.animState=e}start(e){this.objects.push(Et.start),this.objects.push(e),this.animState.animationsChanged=!0}interrupt(e){this.objects.push(Et.interrupt),this.objects.push(e)}end(e){this.objects.push(Et.end),this.objects.push(e),this.animState.animationsChanged=!0}dispose(e){this.objects.push(Et.dispose),this.objects.push(e)}complete(e){this.objects.push(Et.complete),this.objects.push(e)}event(e,t){this.objects.push(Et.event),this.objects.push(e),this.objects.push(t)}deprecateStuff(){return Me.deprecatedWarning1||(Me.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const e=this.objects,t=this.animState.listeners;for(let n=0;n<e.length;n+=2){const s=e[n],r=e[n+1];switch(s){case Et.start:r.listener!=null&&r.listener.start&&r.listener.start(r);for(let o=0;o<t.length;o++)t[o].start&&t[o].start(r);r.onStart&&this.deprecateStuff()&&r.onStart(r.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(r.trackIndex);break;case Et.interrupt:r.listener!=null&&r.listener.interrupt&&r.listener.interrupt(r);for(let o=0;o<t.length;o++)t[o].interrupt&&t[o].interrupt(r);break;case Et.end:r.listener!=null&&r.listener.end&&r.listener.end(r);for(let o=0;o<t.length;o++)t[o].end&&t[o].end(r);r.onEnd&&this.deprecateStuff()&&r.onEnd(r.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(r.trackIndex);case Et.dispose:r.listener!=null&&r.listener.dispose&&r.listener.dispose(r);for(let o=0;o<t.length;o++)t[o].dispose&&t[o].dispose(r);this.animState.trackEntryPool.free(r);break;case Et.complete:r.listener!=null&&r.listener.complete&&r.listener.complete(r);for(let o=0;o<t.length;o++)t[o].complete&&t[o].complete(r);const l=A.toInt(r.loopsCount());r.onComplete&&this.deprecateStuff()&&r.onComplete(r.trackIndex,l),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(r.trackIndex,l);break;case Et.event:const c=e[n+++2];r.listener!=null&&r.listener.event&&r.listener.event(r,c);for(let o=0;o<t.length;o++)t[o].event&&t[o].event(r,c);r.onEvent&&this.deprecateStuff()&&r.onEvent(r.trackIndex,c),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(r.trackIndex,c);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};let ye=Me;ye.deprecatedWarning1=!1;var Et=(e=>(e[e.start=0]="start",e[e.interrupt=1]="interrupt",e[e.end=2]="end",e[e.dispose=3]="dispose",e[e.complete=4]="complete",e[e.event=5]="event",e))(Et||{});class In{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,n){}}const Ae=class{constructor(e){if(this.animationToMixTime={},this.defaultMix=0,e==null)throw new Error("skeletonData cannot be null.");this.skeletonData=e}setMix(e,t,n){const s=this.skeletonData.findAnimation(e);if(s==null)throw new Error(`Animation not found: ${e}`);const r=this.skeletonData.findAnimation(t);if(r==null)throw new Error(`Animation not found: ${t}`);this.setMixWith(s,r,n)}setMixByName(e,t,n){Ae.deprecatedWarning1||(Ae.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(e,t,n)}setMixWith(e,t,n){if(e==null)throw new Error("from cannot be null.");if(t==null)throw new Error("to cannot be null.");const s=`${e.name}.${t.name}`;this.animationToMixTime[s]=n}getMix(e,t){const n=`${e.name}.${t.name}`,s=this.animationToMixTime[n];return s===void 0?this.defaultMix:s}};let Ce=Ae;Ce.deprecatedWarning1=!1;class en{constructor(t){this.atlas=t}newRegionAttachment(t,n,s){const r=this.atlas.findRegion(s);if(r==null)throw new Error(`Region not found in atlas: ${s} (region attachment: ${n})`);const l=new L(n);return l.region=r,l}newMeshAttachment(t,n,s){const r=this.atlas.findRegion(s);if(r==null)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${n})`);const l=new Ut(n);return l.region=r,l}newBoundingBoxAttachment(t,n){return new re(n)}newPathAttachment(t,n){return new qt(n)}newPointAttachment(t,n){return new ae(n)}newClippingAttachment(t,n){return new ie(n)}}class Ie{constructor(t,n,s){if(this.matrix=new D.Matrix,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.sorted=!1,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=n,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,n,s,r,l,c,o){this.ax=t,this.ay=n,this.arotation=s,this.ascaleX=r,this.ascaleY=l,this.ashearX=c,this.ashearY=o,this.appliedValid=!0;const i=this.parent,a=this.matrix,h=this.skeleton.scaleX,f=Zt.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(i==null){const g=this.skeleton,w=s+90+o;a.a=A.cosDeg(s+c)*r*h,a.c=A.cosDeg(w)*l*h,a.b=A.sinDeg(s+c)*r*f,a.d=A.sinDeg(w)*l*f,a.tx=t*h+g.x,a.ty=n*f+g.y;return}let d=i.matrix.a,u=i.matrix.c,m=i.matrix.b,p=i.matrix.d;switch(a.tx=d*t+u*n+i.matrix.tx,a.ty=m*t+p*n+i.matrix.ty,this.data.transformMode){case z.Normal:{const g=s+90+o,w=A.cosDeg(s+c)*r,S=A.cosDeg(g)*l,E=A.sinDeg(s+c)*r,x=A.sinDeg(g)*l;a.a=d*w+u*E,a.c=d*S+u*x,a.b=m*w+p*E,a.d=m*S+p*x;return}case z.OnlyTranslation:{const g=s+90+o;a.a=A.cosDeg(s+c)*r,a.c=A.cosDeg(g)*l,a.b=A.sinDeg(s+c)*r,a.d=A.sinDeg(g)*l;break}case z.NoRotationOrReflection:{let g=d*d+m*m,w=0;g>1e-4?(g=Math.abs(d*p-u*m)/g,d/=this.skeleton.scaleX,m/=this.skeleton.scaleY,u=m*g,p=d*g,w=Math.atan2(m,d)*A.radDeg):(d=0,m=0,w=90-Math.atan2(p,u)*A.radDeg);const S=s+c-w,E=s+o-w+90,x=A.cosDeg(S)*r,y=A.cosDeg(E)*l,b=A.sinDeg(S)*r,M=A.sinDeg(E)*l;a.a=d*x-u*b,a.c=d*y-u*M,a.b=m*x+p*b,a.d=m*y+p*M;break}case z.NoScale:case z.NoScaleOrReflection:{const g=A.cosDeg(s),w=A.sinDeg(s);let S=(d*g+u*w)/h,E=(m*g+p*w)/f,x=Math.sqrt(S*S+E*E);x>1e-5&&(x=1/x),S*=x,E*=x,x=Math.sqrt(S*S+E*E),this.data.transformMode==z.NoScale&&d*p-u*m<0!=(Zt.yDown?this.skeleton.scaleX<0!=this.skeleton.scaleY>0:this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(x=-x);const y=Math.PI/2+Math.atan2(E,S),b=Math.cos(y)*x,M=Math.sin(y)*x,T=A.cosDeg(c)*r,R=A.cosDeg(90+o)*l,P=A.sinDeg(c)*r,v=A.sinDeg(90+o)*l;a.a=S*T+b*P,a.c=S*R+b*v,a.b=E*T+M*P,a.d=E*R+M*v;break}}a.a*=h,a.c*=h,a.b*=f,a.d*=f}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*A.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*A.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,n=this.matrix;if(t==null){this.ax=n.tx,this.ay=n.ty,this.arotation=Math.atan2(n.b,n.a)*A.radDeg,this.ascaleX=Math.sqrt(n.a*n.a+n.b*n.b),this.ascaleY=Math.sqrt(n.c*n.c+n.d*n.d),this.ashearX=0,this.ashearY=Math.atan2(n.a*n.c+n.b*n.d,n.a*n.d-n.b*n.c)*A.radDeg;return}const s=t.matrix,r=1/(s.a*s.d-s.b*s.c),l=n.tx-s.tx,c=n.ty-s.ty;this.ax=l*s.d*r-c*s.c*r,this.ay=c*s.a*r-l*s.b*r;const o=r*s.d,i=r*s.a,a=r*s.c,h=r*s.b,f=o*n.a-a*n.b,d=o*n.c-a*n.d,u=i*n.b-h*n.a,m=i*n.d-h*n.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(f*f+u*u),this.ascaleX>1e-4){const p=f*m-d*u;this.ascaleY=p/this.ascaleX,this.ashearY=Math.atan2(f*d+u*m,p)*A.radDeg,this.arotation=Math.atan2(u,f)*A.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(d*d+m*m),this.ashearY=0,this.arotation=90-Math.atan2(m,d)*A.radDeg}worldToLocal(t){const n=this.matrix,s=n.a,r=n.c,l=n.b,c=n.d,o=1/(s*c-r*l),i=t.x-n.tx,a=t.y-n.ty;return t.x=i*c*o-a*r*o,t.y=a*s*o-i*l*o,t}localToWorld(t){const n=this.matrix,s=t.x,r=t.y;return t.x=s*n.a+r*n.c+n.tx,t.y=s*n.b+r*n.d+n.ty,t}worldToLocalRotation(t){const n=A.sinDeg(t),s=A.cosDeg(t),r=this.matrix;return Math.atan2(r.a*n-r.b*s,r.d*s-r.c*n)*A.radDeg}localToWorldRotation(t){const n=A.sinDeg(t),s=A.cosDeg(t),r=this.matrix;return Math.atan2(s*r.b+n*r.d,s*r.a+n*r.c)*A.radDeg}rotateWorld(t){const n=this.matrix,s=n.a,r=n.c,l=n.b,c=n.d,o=A.cosDeg(t),i=A.sinDeg(t);n.a=o*s-i*l,n.c=o*r-i*c,n.b=i*s+o*l,n.d=i*r+o*c,this.appliedValid=!1}}class Re{constructor(t,n,s){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=z.Normal,this.skinRequired=!1,this.color=new X,t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");this.index=t,this.name=n,this.parent=s}}class he{constructor(t,n,s){this.name=t,this.order=n,this.skinRequired=s}}class Te{constructor(t,n){if(n==null)throw new Error("data cannot be null.");this.time=t,this.data=n}}class ke{constructor(t){this.name=t}}class nn{constructor(t,n){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(n.findBone(t.bones[s].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,n=this.bones;switch(n.length){case 1:this.apply1(n[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(n[0],n[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,n,s,r,l,c,o){t.appliedValid||t.updateAppliedTransform();const i=t.parent.matrix,a=i.a;let h=i.c;const f=i.b;let d=i.d,u=-t.ashearX-t.arotation,m=0,p=0;switch(t.data.transformMode){case z.OnlyTranslation:m=n-t.worldX,p=s-t.worldY;break;case z.NoRotationOrReflection:const S=Math.abs(a*d-h*f)/(a*a+f*f),E=a/t.skeleton.scaleX,x=f/t.skeleton.scaleY;h=-x*S*t.skeleton.scaleX,d=E*S*t.skeleton.scaleY,u+=Math.atan2(x,E)*A.radDeg;default:const y=n-i.tx,b=s-i.ty,M=a*d-h*f;m=(y*d-b*h)/M-t.ax,p=(b*a-y*f)/M-t.ay}u+=Math.atan2(p,m)*A.radDeg,t.ascaleX<0&&(u+=180),u>180?u-=360:u<-180&&(u+=360);let g=t.ascaleX,w=t.ascaleY;if(r||l){switch(t.data.transformMode){case z.NoScale:case z.NoScaleOrReflection:m=n-t.worldX,p=s-t.worldY}const S=t.data.length*g,E=Math.sqrt(m*m+p*p);if(r&&E<S||l&&E>S&&S>1e-4){const x=(E/S-1)*o+1;g*=x,c&&(w*=x)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+u*o,g,w,t.ashearX,t.ashearY)}apply2(t,n,s,r,l,c,o,i){if(i==0){n.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),n.appliedValid||n.updateAppliedTransform();const a=t.ax,h=t.ay;let f=t.ascaleX,d=f,u=t.ascaleY,m=n.ascaleX;const p=t.matrix;let g=0,w=0,S=0;f<0?(f=-f,g=180,S=-1):(g=0,S=1),u<0&&(u=-u,S=-S),m<0?(m=-m,w=180):w=0;const E=n.ax;let x=0,y=0,b=0,M=p.a,T=p.c,R=p.b,P=p.d;const v=Math.abs(f-u)<=1e-4;v?(x=n.ay,y=M*E+T*x+p.tx,b=R*E+P*x+p.ty):(x=0,y=M*E+p.tx,b=R*E+p.ty);const _=t.parent.matrix;M=_.a,T=_.c,R=_.b,P=_.d;const B=1/(M*P-T*R);let N=y-_.tx,F=b-_.ty;const mt=(N*P-F*T)*B-a,gt=(F*M-N*R)*B-h,V=Math.sqrt(mt*mt+gt*gt);let O=n.data.length*m,W,G;if(V<1e-4){this.apply1(t,s,r,!1,c,!1,i),n.updateWorldTransformWith(E,x,0,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY);return}N=s-_.tx,F=r-_.ty;let J=(N*P-F*T)*B-a,H=(F*M-N*R)*B-h,Y=J*J+H*H;if(o!=0){o*=f*(m+1)/2;const St=Math.sqrt(Y),Ft=St-V-O*f+o;if(Ft>0){let Lt=Math.min(1,Ft/(o*2))-1;Lt=(Ft-o*(1-Lt*Lt))/St,J-=Lt*J,H-=Lt*H,Y=J*J+H*H}}t:if(v){O*=f;let St=(Y-V*V-O*O)/(2*V*O);St<-1?St=-1:St>1&&(St=1,c&&(d*=(Math.sqrt(Y)/(V+O)-1)*i+1)),G=Math.acos(St)*l,M=V+O*St,T=O*Math.sin(G),W=Math.atan2(H*M-J*T,J*M+H*T)}else{M=f*O,T=u*O;const St=M*M,Ft=T*T,Lt=Math.atan2(H,J);R=Ft*V*V+St*Y-St*Ft;const de=-2*Ft*V,rn=Ft-St;if(P=de*de-4*rn*R,P>=0){let Kt=Math.sqrt(P);de<0&&(Kt=-Kt),Kt=-(de+Kt)/2;const cn=Kt/rn,dn=R/Kt,Jt=Math.abs(cn)<Math.abs(dn)?cn:dn;if(Jt*Jt<=Y){F=Math.sqrt(Y-Jt*Jt)*l,W=Lt-Math.atan2(F,Jt),G=Math.atan2(F/u,(Jt-V)/f);break t}}let an=A.PI,ue=V-M,Ye=ue*ue,on=0,ln=0,fe=V+M,_e=fe*fe,hn=0;R=-M*V/(St-Ft),R>=-1&&R<=1&&(R=Math.acos(R),N=M*Math.cos(R)+V,F=T*Math.sin(R),P=N*N+F*F,P<Ye&&(an=R,Ye=P,ue=N,on=F),P>_e&&(ln=R,_e=P,fe=N,hn=F)),Y<=(Ye+_e)/2?(W=Lt-Math.atan2(on*l,ue),G=an*l):(W=Lt-Math.atan2(hn*l,fe),G=ln*l)}const At=Math.atan2(x,E)*S;let Ot=t.arotation;W=(W-At)*A.radDeg+g-Ot,W>180?W-=360:W<-180&&(W+=360),t.updateWorldTransformWith(a,h,Ot+W*i,d,t.ascaleY,0,0),Ot=n.arotation,G=((G+At)*A.radDeg-n.ashearX)*S+w-Ot,G>180?G-=360:G<-180&&(G+=360),n.updateWorldTransformWith(E,x,Ot+G*i,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}}class Pe extends he{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class ve extends he{constructor(t){super(t,0,!1),this.bones=new Array}}var it=(e=>(e[e.Length=0]="Length",e[e.Fixed=1]="Fixed",e[e.Percent=2]="Percent",e))(it||{});const Gt=class{constructor(e,t){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,e==null)throw new Error("data cannot be null.");if(t==null)throw new Error("skeleton cannot be null.");this.data=e,this.bones=new Array;for(let n=0,s=e.bones.length;n<s;n++)this.bones.push(t.findBone(e.bones[n].name));this.target=t.findSlot(e.target.name),this.position=e.position,this.spacing=e.spacing,this.rotateMix=e.rotateMix,this.translateMix=e.translateMix}isActive(){return this.active}apply(){this.update()}update(){const e=this.target.getAttachment();if(!(e instanceof qt))return;const t=this.rotateMix,n=this.translateMix,s=n>0,r=t>0;if(!s&&!r)return;const l=this.data,c=l.spacingMode,o=c==it.Length,i=l.rotateMode,a=i==It.Tangent,h=i==It.ChainScale,f=this.bones.length,d=a?f:f+1,u=this.bones,m=k.setArraySize(this.spaces,d);let p=null;const g=this.spacing;if(h||o){h&&(p=k.setArraySize(this.lengths,f));for(let b=0,M=d-1;b<M;){const T=u[b],R=T.data.length;if(R<Gt.epsilon)h&&(p[b]=0),m[++b]=0;else{const P=R*T.matrix.a,v=R*T.matrix.b,_=Math.sqrt(P*P+v*v);h&&(p[b]=_),m[++b]=(o?R+g:g)*_/R}}}else for(let b=1;b<d;b++)m[b]=g;const w=this.computeWorldPositions(e,d,a,l.positionMode==Ct.Percent,c==it.Percent);let S=w[0],E=w[1],x=l.offsetRotation,y=!1;if(x==0)y=i==It.Chain;else{y=!1;const b=this.target.bone.matrix;x*=b.a*b.d-b.b*b.c>0?A.degRad:-A.degRad}for(let b=0,M=3;b<f;b++,M+=3){const T=u[b],R=T.matrix;R.tx+=(S-R.tx)*n,R.ty+=(E-R.ty)*n;const P=w[M],v=w[M+1],_=P-S,B=v-E;if(h){const N=p[b];if(N!=0){const F=(Math.sqrt(_*_+B*B)/N-1)*t+1;R.a*=F,R.b*=F}}if(S=P,E=v,r){const N=R.a,F=R.c,mt=R.b,gt=R.d;let V=0,O=0,W=0;if(a&&(a?V=w[M-1]:m[b+1]==0?V=w[M+2]:V=Math.atan2(B,_)),V-=Math.atan2(mt,N),y){O=Math.cos(V),W=Math.sin(V);const G=T.data.length;S+=(G*(O*N-W*mt)-_)*t,E+=(G*(W*N+O*mt)-B)*t}else V+=x;V>A.PI?V-=A.PI2:V<-A.PI&&(V+=A.PI2),V*=t,O=Math.cos(V),W=Math.sin(V),R.a=O*N-W*mt,R.c=O*F-W*gt,R.b=W*N+O*mt,R.d=W*F+O*gt}T.appliedValid=!1}}computeWorldPositions(e,t,n,s,r){const l=this.target;let c=this.position;const o=this.spaces,i=k.setArraySize(this.positions,t*3+2);let a=null;const h=e.closed;let f=e.worldVerticesLength,d=f/6,u=Gt.NONE;if(!e.constantSpeed){const V=e.lengths;d-=h?1:2;const O=V[d];if(s&&(c*=O),r)for(let W=0;W<t;W++)o[W]*=O;a=k.setArraySize(this.world,8);for(let W=0,G=0,J=0;W<t;W++,G+=3){const H=o[W];c+=H;let Y=c;if(h)Y%=O,Y<0&&(Y+=O),J=0;else if(Y<0){u!=Gt.BEFORE&&(u=Gt.BEFORE,e.computeWorldVertices(l,2,4,a,0,2)),this.addBeforePosition(Y,a,0,i,G);continue}else if(Y>O){u!=Gt.AFTER&&(u=Gt.AFTER,e.computeWorldVertices(l,f-6,4,a,0,2)),this.addAfterPosition(Y-O,a,0,i,G);continue}for(;;J++){const At=V[J];if(!(Y>At)){if(J==0)Y/=At;else{const Ot=V[J-1];Y=(Y-Ot)/(At-Ot)}break}}J!=u&&(u=J,h&&J==d?(e.computeWorldVertices(l,f-4,4,a,0,2),e.computeWorldVertices(l,0,4,a,4,2)):e.computeWorldVertices(l,J*6+2,8,a,0,2)),this.addCurvePosition(Y,a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],i,G,n||W>0&&H==0)}return i}h?(f+=2,a=k.setArraySize(this.world,f),e.computeWorldVertices(l,2,f-4,a,0,2),e.computeWorldVertices(l,0,2,a,f-4,2),a[f-2]=a[0],a[f-1]=a[1]):(d--,f-=4,a=k.setArraySize(this.world,f),e.computeWorldVertices(l,2,f,a,0,2));const m=k.setArraySize(this.curves,d);let p=0,g=a[0],w=a[1],S=0,E=0,x=0,y=0,b=0,M=0,T=0,R=0,P=0,v=0,_=0,B=0,N=0,F=0;for(let V=0,O=2;V<d;V++,O+=6)S=a[O],E=a[O+1],x=a[O+2],y=a[O+3],b=a[O+4],M=a[O+5],T=(g-S*2+x)*.1875,R=(w-E*2+y)*.1875,P=((S-x)*3-g+b)*.09375,v=((E-y)*3-w+M)*.09375,_=T*2+P,B=R*2+v,N=(S-g)*.75+T+P*.16666667,F=(E-w)*.75+R+v*.16666667,p+=Math.sqrt(N*N+F*F),N+=_,F+=B,_+=P,B+=v,p+=Math.sqrt(N*N+F*F),N+=_,F+=B,p+=Math.sqrt(N*N+F*F),N+=_+P,F+=B+v,p+=Math.sqrt(N*N+F*F),m[V]=p,g=b,w=M;if(s&&(c*=p),r)for(let V=0;V<t;V++)o[V]*=p;const mt=this.segments;let gt=0;for(let V=0,O=0,W=0,G=0;V<t;V++,O+=3){const J=o[V];c+=J;let H=c;if(h)H%=p,H<0&&(H+=p),W=0;else if(H<0){this.addBeforePosition(H,a,0,i,O);continue}else if(H>p){this.addAfterPosition(H-p,a,f-4,i,O);continue}for(;;W++){const Y=m[W];if(!(H>Y)){if(W==0)H/=Y;else{const At=m[W-1];H=(H-At)/(Y-At)}break}}if(W!=u){u=W;let Y=W*6;for(g=a[Y],w=a[Y+1],S=a[Y+2],E=a[Y+3],x=a[Y+4],y=a[Y+5],b=a[Y+6],M=a[Y+7],T=(g-S*2+x)*.03,R=(w-E*2+y)*.03,P=((S-x)*3-g+b)*.006,v=((E-y)*3-w+M)*.006,_=T*2+P,B=R*2+v,N=(S-g)*.3+T+P*.16666667,F=(E-w)*.3+R+v*.16666667,gt=Math.sqrt(N*N+F*F),mt[0]=gt,Y=1;Y<8;Y++)N+=_,F+=B,_+=P,B+=v,gt+=Math.sqrt(N*N+F*F),mt[Y]=gt;N+=_,F+=B,gt+=Math.sqrt(N*N+F*F),mt[8]=gt,N+=_+P,F+=B+v,gt+=Math.sqrt(N*N+F*F),mt[9]=gt,G=0}for(H*=gt;;G++){const Y=mt[G];if(!(H>Y)){if(G==0)H/=Y;else{const At=mt[G-1];H=G+(H-At)/(Y-At)}break}}this.addCurvePosition(H*.1,g,w,S,E,x,y,b,M,i,O,n||V>0&&J==0)}return i}addBeforePosition(e,t,n,s,r){const l=t[n],c=t[n+1],o=t[n+2]-l,i=t[n+3]-c,a=Math.atan2(i,o);s[r]=l+e*Math.cos(a),s[r+1]=c+e*Math.sin(a),s[r+2]=a}addAfterPosition(e,t,n,s,r){const l=t[n+2],c=t[n+3],o=l-t[n],i=c-t[n+1],a=Math.atan2(i,o);s[r]=l+e*Math.cos(a),s[r+1]=c+e*Math.sin(a),s[r+2]=a}addCurvePosition(e,t,n,s,r,l,c,o,i,a,h,f){(e==0||isNaN(e))&&(e=1e-4);const d=e*e,u=d*e,m=1-e,p=m*m,g=p*m,w=m*e,S=w*3,E=m*S,x=S*e,y=t*g+s*E+l*x+o*u,b=n*g+r*E+c*x+i*u;a[h]=y,a[h+1]=b,f&&(a[h+2]=Math.atan2(b-(n*p+r*w*2+c*d),y-(t*p+s*w*2+l*d)))}};let Qt=Gt;Qt.NONE=-1,Qt.BEFORE=-2,Qt.AFTER=-3,Qt.epsilon=1e-5;class sn{constructor(t,n){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new qe,this.active=!1,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(n.findBone(t.bones[s].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,r=this.shearMix,l=this.target,c=l.matrix,o=c.a,i=c.c,a=c.b,h=c.d,f=o*h-i*a>0?A.degRad:-A.degRad,d=this.data.offsetRotation*f,u=this.data.offsetShearY*f,m=this.bones;for(let p=0,g=m.length;p<g;p++){const w=m[p];let S=!1;const E=w.matrix;if(t!=0){const x=E.a,y=E.c,b=E.b,M=E.d;let T=Math.atan2(a,o)-Math.atan2(b,x)+d;T>A.PI?T-=A.PI2:T<-A.PI&&(T+=A.PI2),T*=t;const R=Math.cos(T),P=Math.sin(T);E.a=R*x-P*b,E.c=R*y-P*M,E.b=P*x+R*b,E.d=P*y+R*M,S=!0}if(n!=0){const x=this.temp;l.localToWorld(x.set(this.data.offsetX,this.data.offsetY)),E.tx+=(x.x-E.tx)*n,E.ty+=(x.y-E.ty)*n,S=!0}if(s>0){let x=Math.sqrt(E.a*E.a+E.b*E.b),y=Math.sqrt(o*o+a*a);x>1e-5&&(x=(x+(y-x+this.data.offsetScaleX)*s)/x),E.a*=x,E.b*=x,x=Math.sqrt(E.c*E.c+E.d*E.d),y=Math.sqrt(i*i+h*h),x>1e-5&&(x=(x+(y-x+this.data.offsetScaleY)*s)/x),E.c*=x,E.d*=x,S=!0}if(r>0){const x=E.c,y=E.d,b=Math.atan2(y,x);let M=Math.atan2(h,i)-Math.atan2(a,o)-(b-Math.atan2(E.b,E.a));M>A.PI?M-=A.PI2:M<-A.PI&&(M+=A.PI2),M=b+(M+u)*r;const T=Math.sqrt(x*x+y*y);E.c=Math.cos(M)*T,E.d=Math.sin(M)*T,S=!0}S&&(w.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,r=this.shearMix,l=this.target,c=l.matrix,o=c.a,i=c.c,a=c.b,h=c.d,f=o*h-i*a>0?A.degRad:-A.degRad,d=this.data.offsetRotation*f,u=this.data.offsetShearY*f,m=this.bones;for(let p=0,g=m.length;p<g;p++){const w=m[p];let S=!1;const E=w.matrix;if(t!=0){const x=E.a,y=E.c,b=E.b,M=E.d;let T=Math.atan2(a,o)+d;T>A.PI?T-=A.PI2:T<-A.PI&&(T+=A.PI2),T*=t;const R=Math.cos(T),P=Math.sin(T);E.a=R*x-P*b,E.c=R*y-P*M,E.b=P*x+R*b,E.d=P*y+R*M,S=!0}if(n!=0){const x=this.temp;l.localToWorld(x.set(this.data.offsetX,this.data.offsetY)),E.tx+=x.x*n,E.ty+=x.y*n,S=!0}if(s>0){let x=(Math.sqrt(o*o+a*a)-1+this.data.offsetScaleX)*s+1;E.a*=x,E.b*=x,x=(Math.sqrt(i*i+h*h)-1+this.data.offsetScaleY)*s+1,E.c*=x,E.d*=x,S=!0}if(r>0){let x=Math.atan2(h,i)-Math.atan2(a,o);x>A.PI?x-=A.PI2:x<-A.PI&&(x+=A.PI2);const y=E.c,b=E.d;x=Math.atan2(b,y)+(x-A.PI/2+u)*r;const M=Math.sqrt(y*y+b*b);E.c=Math.cos(x)*M,E.d=Math.sin(x)*M,S=!0}S&&(w.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,r=this.shearMix,l=this.target;l.appliedValid||l.updateAppliedTransform();const c=this.bones;for(let o=0,i=c.length;o<i;o++){const a=c[o];a.appliedValid||a.updateAppliedTransform();let h=a.arotation;if(t!=0){let g=l.arotation-h+this.data.offsetRotation;g-=(16384-(16384.499999999996-g/360|0))*360,h+=g*t}let f=a.ax,d=a.ay;n!=0&&(f+=(l.ax-f+this.data.offsetX)*n,d+=(l.ay-d+this.data.offsetY)*n);let u=a.ascaleX,m=a.ascaleY;s>0&&(u>1e-5&&(u=(u+(l.ascaleX-u+this.data.offsetScaleX)*s)/u),m>1e-5&&(m=(m+(l.ascaleY-m+this.data.offsetScaleY)*s)/m));const p=a.ashearY;if(r>0){let g=l.ashearY-p+this.data.offsetShearY;g-=(16384-(16384.499999999996-g/360|0))*360,a.shearY+=g*r}a.updateWorldTransformWith(f,d,h,u,m,a.ashearX,p)}}applyRelativeLocal(){const t=this.rotateMix,n=this.translateMix,s=this.scaleMix,r=this.shearMix,l=this.target;l.appliedValid||l.updateAppliedTransform();const c=this.bones;for(let o=0,i=c.length;o<i;o++){const a=c[o];a.appliedValid||a.updateAppliedTransform();let h=a.arotation;t!=0&&(h+=(l.arotation+this.data.offsetRotation)*t);let f=a.ax,d=a.ay;n!=0&&(f+=(l.ax+this.data.offsetX)*n,d+=(l.ay+this.data.offsetY)*n);let u=a.ascaleX,m=a.ascaleY;s>0&&(u>1e-5&&(u*=(l.ascaleX-1+this.data.offsetScaleX)*s+1),m>1e-5&&(m*=(l.ascaleY-1+this.data.offsetScaleY)*s+1));let p=a.ashearY;r>0&&(p+=(l.ashearY+this.data.offsetShearY)*r),a.updateWorldTransformWith(f,d,h,u,m,a.ashearX,p)}}}const te=class{constructor(e){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,e==null)throw new Error("data cannot be null.");this.data=e,this.bones=new Array;for(let t=0;t<e.bones.length;t++){const n=e.bones[t];let s;if(n.parent==null)s=new Ie(n,this,null);else{const r=this.bones[n.parent.index];s=new Ie(n,this,r),r.children.push(s)}this.bones.push(s)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<e.slots.length;t++){const n=e.slots[t],s=this.bones[n.boneData.index],r=new Se(n,s);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let t=0;t<e.ikConstraints.length;t++){const n=e.ikConstraints[t];this.ikConstraints.push(new nn(n,this))}this.transformConstraints=new Array;for(let t=0;t<e.transformConstraints.length;t++){const n=e.transformConstraints[t];this.transformConstraints.push(new sn(n,this))}this.pathConstraints=new Array;for(let t=0;t<e.pathConstraints.length;t++){const n=e.pathConstraints[t];this.pathConstraints.push(new Qt(n,this))}this.color=new X(1,1,1,1),this.updateCache()}updateCache(){const e=this._updateCache;e.length=0,this.updateCacheReset.length=0;const t=this.bones;for(let a=0,h=t.length;a<h;a++){const f=t[a];f.sorted=f.data.skinRequired,f.active=!f.sorted}if(this.skin!=null){const a=this.skin.bones;for(let h=0,f=this.skin.bones.length;h<f;h++){let d=this.bones[a[h].index];do d.sorted=!1,d.active=!0,d=d.parent;while(d!=null)}}const n=this.ikConstraints,s=this.transformConstraints,r=this.pathConstraints,l=n.length,c=s.length,o=r.length,i=l+c+o;t:for(let a=0;a<i;a++){for(let h=0;h<l;h++){const f=n[h];if(f.data.order==a){this.sortIkConstraint(f);continue t}}for(let h=0;h<c;h++){const f=s[h];if(f.data.order==a){this.sortTransformConstraint(f);continue t}}for(let h=0;h<o;h++){const f=r[h];if(f.data.order==a){this.sortPathConstraint(f);continue t}}}for(let a=0,h=t.length;a<h;a++)this.sortBone(t[a])}sortIkConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&k.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target;this.sortBone(t);const n=e.bones,s=n[0];if(this.sortBone(s),n.length>1){const r=n[n.length-1];this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}this._updateCache.push(e),this.sortReset(s.children),n[n.length-1].sorted=!0}sortPathConstraint(e){if(e.active=e.target.bone.isActive()&&(!e.data.skinRequired||this.skin!=null&&k.contains(this.skin.constraints,e.data,!0)),!e.active)return;const t=e.target,n=t.data.index,s=t.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,n,s),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,s);for(let o=0,i=this.data.skins.length;o<i;o++)this.sortPathConstraintAttachment(this.data.skins[o],n,s);const r=t.getAttachment();r instanceof qt&&this.sortPathConstraintAttachmentWith(r,s);const l=e.bones,c=l.length;for(let o=0;o<c;o++)this.sortBone(l[o]);this._updateCache.push(e);for(let o=0;o<c;o++)this.sortReset(l[o].children);for(let o=0;o<c;o++)l[o].sorted=!0}sortTransformConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||this.skin!=null&&k.contains(this.skin.constraints,e.data,!0)),!e.active)return;this.sortBone(e.target);const t=e.bones,n=t.length;if(e.data.local)for(let s=0;s<n;s++){const r=t[s];this.sortBone(r.parent),this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}else for(let s=0;s<n;s++)this.sortBone(t[s]);this._updateCache.push(e);for(let s=0;s<n;s++)this.sortReset(t[s].children);for(let s=0;s<n;s++)t[s].sorted=!0}sortPathConstraintAttachment(e,t,n){const s=e.attachments[t];if(s)for(const r in s)this.sortPathConstraintAttachmentWith(s[r],n)}sortPathConstraintAttachmentWith(e,t){if(!(e instanceof qt))return;const n=e.bones;if(n==null)this.sortBone(t);else{const s=this.bones;let r=0;for(;r<n.length;){const l=n[r++];for(let c=r+l;r<c;r++){const o=n[r];this.sortBone(s[o])}}}}sortBone(e){if(e.sorted)return;const t=e.parent;t!=null&&this.sortBone(t),e.sorted=!0,this._updateCache.push(e)}sortReset(e){for(let t=0,n=e.length;t<n;t++){const s=e[t];s.active&&(s.sorted&&this.sortReset(s.children),s.sorted=!1)}}updateWorldTransform(){const e=this.updateCacheReset;for(let n=0,s=e.length;n<s;n++){const r=e[n];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY,r.appliedValid=!0}const t=this._updateCache;for(let n=0,s=t.length;n<s;n++)t[n].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const e=this.bones;for(let r=0,l=e.length;r<l;r++)e[r].setToSetupPose();const t=this.ikConstraints;for(let r=0,l=t.length;r<l;r++){const c=t[r];c.mix=c.data.mix,c.softness=c.data.softness,c.bendDirection=c.data.bendDirection,c.compress=c.data.compress,c.stretch=c.data.stretch}const n=this.transformConstraints;for(let r=0,l=n.length;r<l;r++){const c=n[r],o=c.data;c.rotateMix=o.rotateMix,c.translateMix=o.translateMix,c.scaleMix=o.scaleMix,c.shearMix=o.shearMix}const s=this.pathConstraints;for(let r=0,l=s.length;r<l;r++){const c=s[r],o=c.data;c.position=o.position,c.spacing=o.spacing,c.rotateMix=o.rotateMix,c.translateMix=o.translateMix}}setSlotsToSetupPose(){const e=this.slots;k.arrayCopy(e,0,this.drawOrder,0,e.length);for(let t=0,n=e.length;t<n;t++)e[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,s=t.length;n<s;n++){const r=t[n];if(r.data.name==e)return r}return null}findBoneIndex(e){if(e==null)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,s=t.length;n<s;n++)if(t[n].data.name==e)return n;return-1}findSlot(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,s=t.length;n<s;n++){const r=t[n];if(r.data.name==e)return r}return null}findSlotIndex(e){if(e==null)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,s=t.length;n<s;n++)if(t[n].data.name==e)return n;return-1}setSkinByName(e){const t=this.data.findSkin(e);if(t==null)throw new Error(`Skin not found: ${e}`);this.setSkin(t)}setSkin(e){if(e!=this.skin){if(e!=null)if(this.skin!=null)e.attachAll(this,this.skin);else{const t=this.slots;for(let n=0,s=t.length;n<s;n++){const r=t[n],l=r.data.attachmentName;if(l!=null){const c=e.getAttachment(n,l);c!=null&&r.setAttachment(c)}}}this.skin=e,this.updateCache()}}getAttachmentByName(e,t){return this.getAttachment(this.data.findSlotIndex(e),t)}getAttachment(e,t){if(t==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const n=this.skin.getAttachment(e,t);if(n!=null)return n}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(e,t):null}setAttachment(e,t){if(e==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,r=n.length;s<r;s++){const l=n[s];if(l.data.name==e){let c=null;if(t!=null&&(c=this.getAttachment(s,t),c==null))throw new Error(`Attachment not found: ${t}, for slot: ${e}`);l.setAttachment(c);return}}throw new Error(`Slot not found: ${e}`)}findIkConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let n=0,s=t.length;n<s;n++){const r=t[n];if(r.data.name==e)return r}return null}findTransformConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let n=0,s=t.length;n<s;n++){const r=t[n];if(r.data.name==e)return r}return null}findPathConstraint(e){if(e==null)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let n=0,s=t.length;n<s;n++){const r=t[n];if(r.data.name==e)return r}return null}getBounds(e,t,n=new Array(2)){if(e==null)throw new Error("offset cannot be null.");if(t==null)throw new Error("size cannot be null.");const s=this.drawOrder;let r=Number.POSITIVE_INFINITY,l=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let i=0,a=s.length;i<a;i++){const h=s[i];if(!h.bone.active)continue;let f=0,d=null;const u=h.getAttachment();if(u instanceof L)f=8,d=k.setArraySize(n,f,0),u.computeWorldVertices(h.bone,d,0,2);else if(u instanceof Ut){const m=u;f=m.worldVerticesLength,d=k.setArraySize(n,f,0),m.computeWorldVertices(h,0,f,d,0,2)}if(d!=null)for(let m=0,p=d.length;m<p;m+=2){const g=d[m],w=d[m+1];r=Math.min(r,g),l=Math.min(l,w),c=Math.max(c,g),o=Math.max(o,w)}}e.set(r,l),t.set(c-r,o-l)}update(e){this.time+=e}get flipX(){return this.scaleX==-1}set flipX(e){te.deprecatedWarning1||(te.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=e?1:-1}get flipY(){return this.scaleY==-1}set flipY(e){te.deprecatedWarning1||(te.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=e?1:-1}};let Ve=te;Ve.deprecatedWarning1=!1;class Ne{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let s=0,r=n.length;s<r;s++){const l=n[s];if(l.name==t)return l}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const n=this.bones;for(let s=0,r=n.length;s<r;s++)if(n[s].name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,r=n.length;s<r;s++){const l=n[s];if(l.name==t)return l}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const n=this.slots;for(let s=0,r=n.length;s<r;s++)if(n[s].name==t)return s;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const n=this.skins;for(let s=0,r=n.length;s<r;s++){const l=n[s];if(l.name==t)return l}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const n=this.events;for(let s=0,r=n.length;s<r;s++){const l=n[s];if(l.name==t)return l}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const n=this.animations;for(let s=0,r=n.length;s<r;s++){const l=n[s];if(l.name==t)return l}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let s=0,r=n.length;s<r;s++){const l=n[s];if(l.name==t)return l}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let s=0,r=n.length;s<r;s++){const l=n[s];if(l.name==t)return l}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let s=0,r=n.length;s<r;s++){const l=n[s];if(l.name==t)return l}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const n=this.pathConstraints;for(let s=0,r=n.length;s<r;s++)if(n[s].name==t)return s;return-1}}class Fe{constructor(t,n,s){if(this.color=new X(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");if(s==null)throw new Error("boneData cannot be null.");this.index=t,this.name=n,this.boneData=s}}class Le extends he{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class Be{constructor(t,n,s){this.slotIndex=t,this.name=n,this.attachment=s}}class ce{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,n,s){if(s==null)throw new Error("attachment cannot be null.");const r=this.attachments;t>=r.length&&(r.length=t+1),r[t]||(r[t]={}),r[t][n]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const r=t.bones[s];let l=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==r){l=!0;break}l||this.bones.push(r)}for(let s=0;s<t.constraints.length;s++){const r=t.constraints[s];let l=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==r){l=!0;break}l||this.constraints.push(r)}const n=t.getAttachments();for(let s=0;s<n.length;s++){const r=n[s];this.setAttachment(r.slotIndex,r.name,r.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const r=t.bones[s];let l=!1;for(let c=0;c<this.bones.length;c++)if(this.bones[c]==r){l=!0;break}l||this.bones.push(r)}for(let s=0;s<t.constraints.length;s++){const r=t.constraints[s];let l=!1;for(let c=0;c<this.constraints.length;c++)if(this.constraints[c]==r){l=!0;break}l||this.constraints.push(r)}const n=t.getAttachments();for(let s=0;s<n.length;s++){const r=n[s];r.attachment!=null&&(r.attachment instanceof Ut?(r.attachment=r.attachment.newLinkedMesh(),this.setAttachment(r.slotIndex,r.name,r.attachment)):(r.attachment=r.attachment.copy(),this.setAttachment(r.slotIndex,r.name,r.attachment)))}}getAttachment(t,n){const s=this.attachments[t];return s?s[n]:null}removeAttachment(t,n){const s=this.attachments[t];s&&(s[n]=null)}getAttachments(){const t=new Array;for(let n=0;n<this.attachments.length;n++){const s=this.attachments[n];if(s)for(const r in s){const l=s[r];l&&t.push(new Be(n,r,l))}}return t}getAttachmentsForSlot(t,n){const s=this.attachments[t];if(s)for(const r in s){const l=s[r];l&&n.push(new Be(t,r,l))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,n){let s=0;for(let r=0;r<t.slots.length;r++){const l=t.slots[r],c=l.getAttachment();if(c&&s<n.attachments.length){const o=n.attachments[s];for(const i in o){const a=o[i];if(c==a){const h=this.getAttachment(s,i);h!=null&&l.setAttachment(h);break}}}s++}}}const K=class{constructor(e){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=e}readSkeletonData(e){const t=this.scale,n=new Ne;n.name="";const s=new De(e);n.hash=s.readString(),n.version=s.readString(),n.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),n.x=s.readFloat(),n.y=s.readFloat(),n.width=s.readFloat(),n.height=s.readFloat();const r=s.readBoolean();r&&(n.fps=s.readFloat(),n.imagesPath=s.readString(),n.audioPath=s.readString());let l=0;l=s.readInt(!0);for(let o=0;o<l;o++)s.strings.push(s.readString());l=s.readInt(!0);for(let o=0;o<l;o++){const i=s.readString(),a=o==0?null:n.bones[s.readInt(!0)],h=new Re(o,i,a);h.rotation=s.readFloat(),h.x=s.readFloat()*t,h.y=s.readFloat()*t,h.scaleX=s.readFloat(),h.scaleY=s.readFloat(),h.shearX=s.readFloat(),h.shearY=s.readFloat(),h.length=s.readFloat()*t,h.transformMode=K.TransformModeValues[s.readInt(!0)],h.skinRequired=s.readBoolean(),r&&X.rgba8888ToColor(h.color,s.readInt32()),n.bones.push(h)}l=s.readInt(!0);for(let o=0;o<l;o++){const i=s.readString(),a=n.bones[s.readInt(!0)],h=new Fe(o,i,a);X.rgba8888ToColor(h.color,s.readInt32());const f=s.readInt32();f!=-1&&X.rgb888ToColor(h.darkColor=new X,f),h.attachmentName=s.readStringRef(),h.blendMode=K.BlendModeValues[s.readInt(!0)],n.slots.push(h)}l=s.readInt(!0);for(let o=0,i;o<l;o++){const a=new Pe(s.readString());a.order=s.readInt(!0),a.skinRequired=s.readBoolean(),i=s.readInt(!0);for(let h=0;h<i;h++)a.bones.push(n.bones[s.readInt(!0)]);a.target=n.bones[s.readInt(!0)],a.mix=s.readFloat(),a.softness=s.readFloat()*t,a.bendDirection=s.readByte(),a.compress=s.readBoolean(),a.stretch=s.readBoolean(),a.uniform=s.readBoolean(),n.ikConstraints.push(a)}l=s.readInt(!0);for(let o=0,i;o<l;o++){const a=new Le(s.readString());a.order=s.readInt(!0),a.skinRequired=s.readBoolean(),i=s.readInt(!0);for(let h=0;h<i;h++)a.bones.push(n.bones[s.readInt(!0)]);a.target=n.bones[s.readInt(!0)],a.local=s.readBoolean(),a.relative=s.readBoolean(),a.offsetRotation=s.readFloat(),a.offsetX=s.readFloat()*t,a.offsetY=s.readFloat()*t,a.offsetScaleX=s.readFloat(),a.offsetScaleY=s.readFloat(),a.offsetShearY=s.readFloat(),a.rotateMix=s.readFloat(),a.translateMix=s.readFloat(),a.scaleMix=s.readFloat(),a.shearMix=s.readFloat(),n.transformConstraints.push(a)}l=s.readInt(!0);for(let o=0,i;o<l;o++){const a=new ve(s.readString());a.order=s.readInt(!0),a.skinRequired=s.readBoolean(),i=s.readInt(!0);for(let h=0;h<i;h++)a.bones.push(n.bones[s.readInt(!0)]);a.target=n.slots[s.readInt(!0)],a.positionMode=K.PositionModeValues[s.readInt(!0)],a.spacingMode=K.SpacingModeValues[s.readInt(!0)],a.rotateMode=K.RotateModeValues[s.readInt(!0)],a.offsetRotation=s.readFloat(),a.position=s.readFloat(),a.positionMode==Ct.Fixed&&(a.position*=t),a.spacing=s.readFloat(),(a.spacingMode==it.Length||a.spacingMode==it.Fixed)&&(a.spacing*=t),a.rotateMix=s.readFloat(),a.translateMix=s.readFloat(),n.pathConstraints.push(a)}const c=this.readSkin(s,n,!0,r);c!=null&&(n.defaultSkin=c,n.skins.push(c));{let o=n.skins.length;for(k.setArraySize(n.skins,l=o+s.readInt(!0));o<l;o++)n.skins[o]=this.readSkin(s,n,!1,r)}l=this.linkedMeshes.length;for(let o=0;o<l;o++){const i=this.linkedMeshes[o],a=i.skin==null?n.defaultSkin:n.findSkin(i.skin);if(a==null)throw new Error(`Skin not found: ${i.skin}`);const h=a.getAttachment(i.slotIndex,i.parent);if(h==null)throw new Error(`Parent mesh not found: ${i.parent}`);i.mesh.deformAttachment=i.inheritDeform?h:i.mesh,i.mesh.setParentMesh(h)}this.linkedMeshes.length=0,l=s.readInt(!0);for(let o=0;o<l;o++){const i=new ke(s.readStringRef());i.intValue=s.readInt(!1),i.floatValue=s.readFloat(),i.stringValue=s.readString(),i.audioPath=s.readString(),i.audioPath!=null&&(i.volume=s.readFloat(),i.balance=s.readFloat()),n.events.push(i)}l=s.readInt(!0);for(let o=0;o<l;o++)n.animations.push(this.readAnimation(s,s.readString(),n));return n}readSkin(e,t,n,s){let r=null,l=0;if(n){if(l=e.readInt(!0),l==0)return null;r=new ce("default")}else{r=new ce(e.readStringRef()),r.bones.length=e.readInt(!0);for(let c=0,o=r.bones.length;c<o;c++)r.bones[c]=t.bones[e.readInt(!0)];for(let c=0,o=e.readInt(!0);c<o;c++)r.constraints.push(t.ikConstraints[e.readInt(!0)]);for(let c=0,o=e.readInt(!0);c<o;c++)r.constraints.push(t.transformConstraints[e.readInt(!0)]);for(let c=0,o=e.readInt(!0);c<o;c++)r.constraints.push(t.pathConstraints[e.readInt(!0)]);l=e.readInt(!0)}for(let c=0;c<l;c++){const o=e.readInt(!0);for(let i=0,a=e.readInt(!0);i<a;i++){const h=e.readStringRef(),f=this.readAttachment(e,t,r,o,h,s);f!=null&&r.setAttachment(o,h,f)}}return r}readAttachment(e,t,n,s,r,l){const c=this.scale;let o=e.readStringRef();o==null&&(o=r);const i=e.readByte();switch(K.AttachmentTypeValues[i]){case $.Region:{let h=e.readStringRef();const f=e.readFloat(),d=e.readFloat(),u=e.readFloat(),m=e.readFloat(),p=e.readFloat(),g=e.readFloat(),w=e.readFloat(),S=e.readInt32();h==null&&(h=o);const E=this.attachmentLoader.newRegionAttachment(n,o,h);return E==null?null:(E.path=h,E.x=d*c,E.y=u*c,E.scaleX=m,E.scaleY=p,E.rotation=f,E.width=g*c,E.height=w*c,X.rgba8888ToColor(E.color,S),E)}case $.BoundingBox:{const h=e.readInt(!0),f=this.readVertices(e,h),d=l?e.readInt32():0,u=this.attachmentLoader.newBoundingBoxAttachment(n,o);return u==null?null:(u.worldVerticesLength=h<<1,u.vertices=f.vertices,u.bones=f.bones,l&&X.rgba8888ToColor(u.color,d),u)}case $.Mesh:{let h=e.readStringRef();const f=e.readInt32(),d=e.readInt(!0),u=this.readFloatArray(e,d<<1,1),m=this.readShortArray(e),p=this.readVertices(e,d),g=e.readInt(!0);let w=null,S=0,E=0;l&&(w=this.readShortArray(e),S=e.readFloat(),E=e.readFloat()),h==null&&(h=o);const x=this.attachmentLoader.newMeshAttachment(n,o,h);return x==null?null:(x.path=h,X.rgba8888ToColor(x.color,f),x.bones=p.bones,x.vertices=p.vertices,x.worldVerticesLength=d<<1,x.triangles=m,x.regionUVs=new Float32Array(u),x.hullLength=g<<1,l&&(x.edges=w,x.width=S*c,x.height=E*c),x)}case $.LinkedMesh:{let h=e.readStringRef();const f=e.readInt32(),d=e.readStringRef(),u=e.readStringRef(),m=e.readBoolean();let p=0,g=0;l&&(p=e.readFloat(),g=e.readFloat()),h==null&&(h=o);const w=this.attachmentLoader.newMeshAttachment(n,o,h);return w==null?null:(w.path=h,X.rgba8888ToColor(w.color,f),l&&(w.width=p*c,w.height=g*c),this.linkedMeshes.push(new Rn(w,d,s,u,m)),w)}case $.Path:{const h=e.readBoolean(),f=e.readBoolean(),d=e.readInt(!0),u=this.readVertices(e,d),m=k.newArray(d/3,0);for(let w=0,S=m.length;w<S;w++)m[w]=e.readFloat()*c;const p=l?e.readInt32():0,g=this.attachmentLoader.newPathAttachment(n,o);return g==null?null:(g.closed=h,g.constantSpeed=f,g.worldVerticesLength=d<<1,g.vertices=u.vertices,g.bones=u.bones,g.lengths=m,l&&X.rgba8888ToColor(g.color,p),g)}case $.Point:{const h=e.readFloat(),f=e.readFloat(),d=e.readFloat(),u=l?e.readInt32():0,m=this.attachmentLoader.newPointAttachment(n,o);return m==null?null:(m.x=f*c,m.y=d*c,m.rotation=h,l&&X.rgba8888ToColor(m.color,u),m)}case $.Clipping:{const h=e.readInt(!0),f=e.readInt(!0),d=this.readVertices(e,f),u=l?e.readInt32():0,m=this.attachmentLoader.newClippingAttachment(n,o);return m==null?null:(m.endSlot=t.slots[h],m.worldVerticesLength=f<<1,m.vertices=d.vertices,m.bones=d.bones,l&&X.rgba8888ToColor(m.color,u),m)}}return null}readVertices(e,t){const n=t<<1,s=new Tn,r=this.scale;if(!e.readBoolean())return s.vertices=this.readFloatArray(e,n,r),s;const l=new Array,c=new Array;for(let o=0;o<t;o++){const i=e.readInt(!0);c.push(i);for(let a=0;a<i;a++)c.push(e.readInt(!0)),l.push(e.readFloat()*r),l.push(e.readFloat()*r),l.push(e.readFloat())}return s.vertices=k.toFloatArray(l),s.bones=c,s}readFloatArray(e,t,n){const s=new Array(t);if(n==1)for(let r=0;r<t;r++)s[r]=e.readFloat();else for(let r=0;r<t;r++)s[r]=e.readFloat()*n;return s}readShortArray(e){const t=e.readInt(!0),n=new Array(t);for(let s=0;s<t;s++)n[s]=e.readShort();return n}readAnimation(e,t,n){const s=new Array,r=this.scale;let l=0;const c=new X,o=new X;for(let h=0,f=e.readInt(!0);h<f;h++){const d=e.readInt(!0);for(let u=0,m=e.readInt(!0);u<m;u++){const p=e.readByte(),g=e.readInt(!0);switch(p){case K.SLOT_ATTACHMENT:{const w=new Ht(g);w.slotIndex=d;for(let S=0;S<g;S++)w.setFrame(S,e.readFloat(),e.readStringRef());s.push(w),l=Math.max(l,w.frames[g-1]);break}case K.SLOT_COLOR:{const w=new dt(g);w.slotIndex=d;for(let S=0;S<g;S++){const E=e.readFloat();X.rgba8888ToColor(c,e.readInt32()),w.setFrame(S,E,c.r,c.g,c.b,c.a),S<g-1&&this.readCurve(e,S,w)}s.push(w),l=Math.max(l,w.frames[(g-1)*dt.ENTRIES]);break}case K.SLOT_TWO_COLOR:{const w=new nt(g);w.slotIndex=d;for(let S=0;S<g;S++){const E=e.readFloat();X.rgba8888ToColor(c,e.readInt32()),X.rgb888ToColor(o,e.readInt32()),w.setFrame(S,E,c.r,c.g,c.b,c.a,o.r,o.g,o.b),S<g-1&&this.readCurve(e,S,w)}s.push(w),l=Math.max(l,w.frames[(g-1)*nt.ENTRIES]);break}}}}for(let h=0,f=e.readInt(!0);h<f;h++){const d=e.readInt(!0);for(let u=0,m=e.readInt(!0);u<m;u++){const p=e.readByte(),g=e.readInt(!0);switch(p){case K.BONE_ROTATE:{const w=new at(g);w.boneIndex=d;for(let S=0;S<g;S++)w.setFrame(S,e.readFloat(),e.readFloat()),S<g-1&&this.readCurve(e,S,w);s.push(w),l=Math.max(l,w.frames[(g-1)*at.ENTRIES]);break}case K.BONE_TRANSLATE:case K.BONE_SCALE:case K.BONE_SHEAR:{let w,S=1;p==K.BONE_SCALE?w=new wt(g):p==K.BONE_SHEAR?w=new xt(g):(w=new bt(g),S=r),w.boneIndex=d;for(let E=0;E<g;E++)w.setFrame(E,e.readFloat(),e.readFloat()*S,e.readFloat()*S),E<g-1&&this.readCurve(e,E,w);s.push(w),l=Math.max(l,w.frames[(g-1)*bt.ENTRIES]);break}}}}for(let h=0,f=e.readInt(!0);h<f;h++){const d=e.readInt(!0),u=e.readInt(!0),m=new ot(u);m.ikConstraintIndex=d;for(let p=0;p<u;p++)m.setFrame(p,e.readFloat(),e.readFloat(),e.readFloat()*r,e.readByte(),e.readBoolean(),e.readBoolean()),p<u-1&&this.readCurve(e,p,m);s.push(m),l=Math.max(l,m.frames[(u-1)*ot.ENTRIES])}for(let h=0,f=e.readInt(!0);h<f;h++){const d=e.readInt(!0),u=e.readInt(!0),m=new ut(u);m.transformConstraintIndex=d;for(let p=0;p<u;p++)m.setFrame(p,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat()),p<u-1&&this.readCurve(e,p,m);s.push(m),l=Math.max(l,m.frames[(u-1)*ut.ENTRIES])}for(let h=0,f=e.readInt(!0);h<f;h++){const d=e.readInt(!0),u=n.pathConstraints[d];for(let m=0,p=e.readInt(!0);m<p;m++){const g=e.readByte(),w=e.readInt(!0);switch(g){case K.PATH_POSITION:case K.PATH_SPACING:{let S,E=1;g==K.PATH_SPACING?(S=new kt(w),(u.spacingMode==it.Length||u.spacingMode==it.Fixed)&&(E=r)):(S=new vt(w),u.positionMode==Ct.Fixed&&(E=r)),S.pathConstraintIndex=d;for(let x=0;x<w;x++)S.setFrame(x,e.readFloat(),e.readFloat()*E),x<w-1&&this.readCurve(e,x,S);s.push(S),l=Math.max(l,S.frames[(w-1)*vt.ENTRIES]);break}case K.PATH_MIX:{const S=new Pt(w);S.pathConstraintIndex=d;for(let E=0;E<w;E++)S.setFrame(E,e.readFloat(),e.readFloat(),e.readFloat()),E<w-1&&this.readCurve(e,E,S);s.push(S),l=Math.max(l,S.frames[(w-1)*Pt.ENTRIES]);break}}}}for(let h=0,f=e.readInt(!0);h<f;h++){const d=n.skins[e.readInt(!0)];for(let u=0,m=e.readInt(!0);u<m;u++){const p=e.readInt(!0);for(let g=0,w=e.readInt(!0);g<w;g++){const S=d.getAttachment(p,e.readStringRef()),E=S.bones!=null,x=S.vertices,y=E?x.length/3*2:x.length,b=e.readInt(!0),M=new be(b);M.slotIndex=p,M.attachment=S;for(let T=0;T<b;T++){const R=e.readFloat();let P,v=e.readInt(!0);if(v==0)P=E?k.newFloatArray(y):x;else{P=k.newFloatArray(y);const _=e.readInt(!0);if(v+=_,r==1)for(let B=_;B<v;B++)P[B]=e.readFloat();else for(let B=_;B<v;B++)P[B]=e.readFloat()*r;if(!E)for(let B=0,N=P.length;B<N;B++)P[B]+=x[B]}M.setFrame(T,R,P),T<b-1&&this.readCurve(e,T,M)}s.push(M),l=Math.max(l,M.frames[b-1])}}}const i=e.readInt(!0);if(i>0){const h=new jt(i),f=n.slots.length;for(let d=0;d<i;d++){const u=e.readFloat(),m=e.readInt(!0),p=k.newArray(f,0);for(let E=f-1;E>=0;E--)p[E]=-1;const g=k.newArray(f-m,0);let w=0,S=0;for(let E=0;E<m;E++){const x=e.readInt(!0);for(;w!=x;)g[S++]=w++;p[w+e.readInt(!0)]=w++}for(;w<f;)g[S++]=w++;for(let E=f-1;E>=0;E--)p[E]==-1&&(p[E]=g[--S]);h.setFrame(d,u,p)}s.push(h),l=Math.max(l,h.frames[i-1])}const a=e.readInt(!0);if(a>0){const h=new oe(a);for(let f=0;f<a;f++){const d=e.readFloat(),u=n.events[e.readInt(!0)],m=new Te(d,u);m.intValue=e.readInt(!1),m.floatValue=e.readFloat(),m.stringValue=e.readBoolean()?e.readString():u.stringValue,m.data.audioPath!=null&&(m.volume=e.readFloat(),m.balance=e.readFloat()),h.setFrame(f,m)}s.push(h),l=Math.max(l,h.frames[a-1])}return new tt(t,s,l)}readCurve(e,t,n){switch(e.readByte()){case K.CURVE_STEPPED:n.setStepped(t);break;case K.CURVE_BEZIER:this.setCurve(n,t,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat());break}}setCurve(e,t,n,s,r,l){e.setCurve(t,n,s,r,l)}};let st=K;st.AttachmentTypeValues=[0,1,2,3,4,5,6],st.TransformModeValues=[z.Normal,z.OnlyTranslation,z.NoRotationOrReflection,z.NoScale,z.NoScaleOrReflection],st.PositionModeValues=[Ct.Fixed,Ct.Percent],st.SpacingModeValues=[it.Length,it.Fixed,it.Percent],st.RotateModeValues=[It.Tangent,It.Chain,It.ChainScale],st.BlendModeValues=[D.BLEND_MODES.NORMAL,D.BLEND_MODES.ADD,D.BLEND_MODES.MULTIPLY,D.BLEND_MODES.SCREEN],st.BONE_ROTATE=0,st.BONE_TRANSLATE=1,st.BONE_SCALE=2,st.BONE_SHEAR=3,st.SLOT_ATTACHMENT=0,st.SLOT_COLOR=1,st.SLOT_TWO_COLOR=2,st.PATH_POSITION=0,st.PATH_SPACING=1,st.PATH_MIX=2,st.CURVE_LINEAR=0,st.CURVE_STEPPED=1,st.CURVE_BEZIER=2;let Rn=class{constructor(t,n,s,r,l){this.mesh=t,this.skin=n,this.slotIndex=s,this.parent=r,this.inheritDeform=l}};class Tn{constructor(t=null,n=null){this.bones=t,this.vertices=n}}class kn extends xe{}class Xt{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,s=new Ne,r=typeof t=="string"?JSON.parse(t):t,l=r.skeleton;if(l!=null){if(s.hash=l.hash,s.version=l.spine,s.version.substr(0,3)!=="3.8"){const c=`Spine 3.8 loader cant load version ${l.spine}. Please configure your pixi-spine bundle`;console.error(c)}s.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),s.x=l.x,s.y=l.y,s.width=l.width,s.height=l.height,s.fps=l.fps,s.imagesPath=l.images}if(r.bones)for(let c=0;c<r.bones.length;c++){const o=r.bones[c];let i=null;const a=this.getValue(o,"parent",null);if(a!=null&&(i=s.findBone(a),i==null))throw new Error(`Parent bone not found: ${a}`);const h=new Re(s.bones.length,o.name,i);h.length=this.getValue(o,"length",0)*n,h.x=this.getValue(o,"x",0)*n,h.y=this.getValue(o,"y",0)*n,h.rotation=this.getValue(o,"rotation",0),h.scaleX=this.getValue(o,"scaleX",1),h.scaleY=this.getValue(o,"scaleY",1),h.shearX=this.getValue(o,"shearX",0),h.shearY=this.getValue(o,"shearY",0),h.transformMode=Xt.transformModeFromString(this.getValue(o,"transform","normal")),h.skinRequired=this.getValue(o,"skin",!1),s.bones.push(h)}if(r.slots)for(let c=0;c<r.slots.length;c++){const o=r.slots[c],i=o.name,a=o.bone,h=s.findBone(a);if(h==null)throw new Error(`Slot bone not found: ${a}`);const f=new Fe(s.slots.length,i,h),d=this.getValue(o,"color",null);d!=null&&f.color.setFromString(d);const u=this.getValue(o,"dark",null);u!=null&&(f.darkColor=new X(1,1,1,1),f.darkColor.setFromString(u)),f.attachmentName=this.getValue(o,"attachment",null),f.blendMode=Xt.blendModeFromString(this.getValue(o,"blend","normal")),s.slots.push(f)}if(r.ik)for(let c=0;c<r.ik.length;c++){const o=r.ik[c],i=new Pe(o.name);i.order=this.getValue(o,"order",0),i.skinRequired=this.getValue(o,"skin",!1);for(let h=0;h<o.bones.length;h++){const f=o.bones[h],d=s.findBone(f);if(d==null)throw new Error(`IK bone not found: ${f}`);i.bones.push(d)}const a=o.target;if(i.target=s.findBone(a),i.target==null)throw new Error(`IK target bone not found: ${a}`);i.mix=this.getValue(o,"mix",1),i.softness=this.getValue(o,"softness",0)*n,i.bendDirection=this.getValue(o,"bendPositive",!0)?1:-1,i.compress=this.getValue(o,"compress",!1),i.stretch=this.getValue(o,"stretch",!1),i.uniform=this.getValue(o,"uniform",!1),s.ikConstraints.push(i)}if(r.transform)for(let c=0;c<r.transform.length;c++){const o=r.transform[c],i=new Le(o.name);i.order=this.getValue(o,"order",0),i.skinRequired=this.getValue(o,"skin",!1);for(let h=0;h<o.bones.length;h++){const f=o.bones[h],d=s.findBone(f);if(d==null)throw new Error(`Transform constraint bone not found: ${f}`);i.bones.push(d)}const a=o.target;if(i.target=s.findBone(a),i.target==null)throw new Error(`Transform constraint target bone not found: ${a}`);i.local=this.getValue(o,"local",!1),i.relative=this.getValue(o,"relative",!1),i.offsetRotation=this.getValue(o,"rotation",0),i.offsetX=this.getValue(o,"x",0)*n,i.offsetY=this.getValue(o,"y",0)*n,i.offsetScaleX=this.getValue(o,"scaleX",0),i.offsetScaleY=this.getValue(o,"scaleY",0),i.offsetShearY=this.getValue(o,"shearY",0),i.rotateMix=this.getValue(o,"rotateMix",1),i.translateMix=this.getValue(o,"translateMix",1),i.scaleMix=this.getValue(o,"scaleMix",1),i.shearMix=this.getValue(o,"shearMix",1),s.transformConstraints.push(i)}if(r.path)for(let c=0;c<r.path.length;c++){const o=r.path[c],i=new ve(o.name);i.order=this.getValue(o,"order",0),i.skinRequired=this.getValue(o,"skin",!1);for(let h=0;h<o.bones.length;h++){const f=o.bones[h],d=s.findBone(f);if(d==null)throw new Error(`Transform constraint bone not found: ${f}`);i.bones.push(d)}const a=o.target;if(i.target=s.findSlot(a),i.target==null)throw new Error(`Path target slot not found: ${a}`);i.positionMode=Xt.positionModeFromString(this.getValue(o,"positionMode","percent")),i.spacingMode=Xt.spacingModeFromString(this.getValue(o,"spacingMode","length")),i.rotateMode=Xt.rotateModeFromString(this.getValue(o,"rotateMode","tangent")),i.offsetRotation=this.getValue(o,"rotation",0),i.position=this.getValue(o,"position",0),i.positionMode==Ct.Fixed&&(i.position*=n),i.spacing=this.getValue(o,"spacing",0),(i.spacingMode==it.Length||i.spacingMode==it.Fixed)&&(i.spacing*=n),i.rotateMix=this.getValue(o,"rotateMix",1),i.translateMix=this.getValue(o,"translateMix",1),s.pathConstraints.push(i)}if(r.skins)for(let c=0;c<r.skins.length;c++){const o=r.skins[c],i=new ce(o.name);if(o.bones)for(let a=0;a<o.bones.length;a++){const h=s.findBone(o.bones[a]);if(h==null)throw new Error(`Skin bone not found: ${o.bones[c]}`);i.bones.push(h)}if(o.ik)for(let a=0;a<o.ik.length;a++){const h=s.findIkConstraint(o.ik[a]);if(h==null)throw new Error(`Skin IK constraint not found: ${o.ik[c]}`);i.constraints.push(h)}if(o.transform)for(let a=0;a<o.transform.length;a++){const h=s.findTransformConstraint(o.transform[a]);if(h==null)throw new Error(`Skin transform constraint not found: ${o.transform[c]}`);i.constraints.push(h)}if(o.path)for(let a=0;a<o.path.length;a++){const h=s.findPathConstraint(o.path[a]);if(h==null)throw new Error(`Skin path constraint not found: ${o.path[c]}`);i.constraints.push(h)}for(const a in o.attachments){const h=s.findSlot(a);if(h==null)throw new Error(`Slot not found: ${a}`);const f=o.attachments[a];for(const d in f){const u=this.readAttachment(f[d],i,h.index,d,s);u!=null&&i.setAttachment(h.index,d,u)}}s.skins.push(i),i.name=="default"&&(s.defaultSkin=i)}for(let c=0,o=this.linkedMeshes.length;c<o;c++){const i=this.linkedMeshes[c],a=i.skin==null?s.defaultSkin:s.findSkin(i.skin);if(a==null)throw new Error(`Skin not found: ${i.skin}`);const h=a.getAttachment(i.slotIndex,i.parent);if(h==null)throw new Error(`Parent mesh not found: ${i.parent}`);i.mesh.deformAttachment=i.inheritDeform?h:i.mesh,i.mesh.setParentMesh(h)}if(this.linkedMeshes.length=0,r.events)for(const c in r.events){const o=r.events[c],i=new ke(c);i.intValue=this.getValue(o,"int",0),i.floatValue=this.getValue(o,"float",0),i.stringValue=this.getValue(o,"string",""),i.audioPath=this.getValue(o,"audio",null),i.audioPath!=null&&(i.volume=this.getValue(o,"volume",1),i.balance=this.getValue(o,"balance",0)),s.events.push(i)}if(r.animations)for(const c in r.animations){const o=r.animations[c];this.readAnimation(o,c,s)}return s}readAttachment(t,n,s,r,l){const c=this.scale;switch(r=this.getValue(t,"name",r),this.getValue(t,"type","region")){case"region":{const i=this.getValue(t,"path",r),a=this.attachmentLoader.newRegionAttachment(n,r,i);if(a==null)return null;a.path=i,a.x=this.getValue(t,"x",0)*c,a.y=this.getValue(t,"y",0)*c,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*c,a.height=t.height*c;const h=this.getValue(t,"color",null);return h!=null&&a.color.setFromString(h),a}case"boundingbox":{const i=this.attachmentLoader.newBoundingBoxAttachment(n,r);if(i==null)return null;this.readVertices(t,i,t.vertexCount<<1);const a=this.getValue(t,"color",null);return a!=null&&i.color.setFromString(a),i}case"mesh":case"linkedmesh":{const i=this.getValue(t,"path",r),a=this.attachmentLoader.newMeshAttachment(n,r,i);if(a==null)return null;a.path=i;const h=this.getValue(t,"color",null);h!=null&&a.color.setFromString(h),a.width=this.getValue(t,"width",0)*c,a.height=this.getValue(t,"height",0)*c;const f=this.getValue(t,"parent",null);if(f!=null)return this.linkedMeshes.push(new Pn(a,this.getValue(t,"skin",null),s,f,this.getValue(t,"deform",!0))),a;const d=t.uvs;return this.readVertices(t,a,d.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(d),a.edges=this.getValue(t,"edges",null),a.hullLength=this.getValue(t,"hull",0)*2,a}case"path":{const i=this.attachmentLoader.newPathAttachment(n,r);if(i==null)return null;i.closed=this.getValue(t,"closed",!1),i.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,i,a<<1);const h=k.newArray(a/3,0);for(let d=0;d<t.lengths.length;d++)h[d]=t.lengths[d]*c;i.lengths=h;const f=this.getValue(t,"color",null);return f!=null&&i.color.setFromString(f),i}case"point":{const i=this.attachmentLoader.newPointAttachment(n,r);if(i==null)return null;i.x=this.getValue(t,"x",0)*c,i.y=this.getValue(t,"y",0)*c,i.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return a!=null&&i.color.setFromString(a),i}case"clipping":{const i=this.attachmentLoader.newClippingAttachment(n,r);if(i==null)return null;const a=this.getValue(t,"end",null);if(a!=null){const d=l.findSlot(a);if(d==null)throw new Error(`Clipping end slot not found: ${a}`);i.endSlot=d}const h=t.vertexCount;this.readVertices(t,i,h<<1);const f=this.getValue(t,"color",null);return f!=null&&i.color.setFromString(f),i}}return null}readVertices(t,n,s){const r=this.scale;n.worldVerticesLength=s;const l=t.vertices;if(s==l.length){const i=k.toFloatArray(l);if(r!=1)for(let a=0,h=l.length;a<h;a++)i[a]*=r;n.vertices=i;return}const c=new Array,o=new Array;for(let i=0,a=l.length;i<a;){const h=l[i++];o.push(h);for(let f=i+h*4;i<f;i+=4)o.push(l[i]),c.push(l[i+1]*r),c.push(l[i+2]*r),c.push(l[i+3])}n.bones=o,n.vertices=k.toFloatArray(c)}readAnimation(t,n,s){const r=this.scale,l=new Array;let c=0;if(t.slots)for(const i in t.slots){const a=t.slots[i],h=s.findSlotIndex(i);if(h==-1)throw new Error(`Slot not found: ${i}`);for(const f in a){const d=a[f];if(f=="attachment"){const u=new Ht(d.length);u.slotIndex=h;let m=0;for(let p=0;p<d.length;p++){const g=d[p];u.setFrame(m++,this.getValue(g,"time",0),g.name)}l.push(u),c=Math.max(c,u.frames[u.getFrameCount()-1])}else if(f=="color"){const u=new dt(d.length);u.slotIndex=h;let m=0;for(let p=0;p<d.length;p++){const g=d[p],w=new X;w.setFromString(g.color||"ffffffff"),u.setFrame(m,this.getValue(g,"time",0),w.r,w.g,w.b,w.a),this.readCurve(g,u,m),m++}l.push(u),c=Math.max(c,u.frames[(u.getFrameCount()-1)*dt.ENTRIES])}else if(f=="twoColor"){const u=new nt(d.length);u.slotIndex=h;let m=0;for(let p=0;p<d.length;p++){const g=d[p],w=new X,S=new X;w.setFromString(g.light),S.setFromString(g.dark),u.setFrame(m,this.getValue(g,"time",0),w.r,w.g,w.b,w.a,S.r,S.g,S.b),this.readCurve(g,u,m),m++}l.push(u),c=Math.max(c,u.frames[(u.getFrameCount()-1)*nt.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${f} (${i})`)}}if(t.bones)for(const i in t.bones){const a=t.bones[i],h=s.findBoneIndex(i);if(h==-1)throw new Error(`Bone not found: ${i}`);for(const f in a){const d=a[f];if(f==="rotate"){const u=new at(d.length);u.boneIndex=h;let m=0;for(let p=0;p<d.length;p++){const g=d[p];u.setFrame(m,this.getValue(g,"time",0),this.getValue(g,"angle",0)),this.readCurve(g,u,m),m++}l.push(u),c=Math.max(c,u.frames[(u.getFrameCount()-1)*at.ENTRIES])}else if(f==="translate"||f==="scale"||f==="shear"){let u=null,m=1,p=0;f==="scale"?(u=new wt(d.length),p=1):f==="shear"?u=new xt(d.length):(u=new bt(d.length),m=r),u.boneIndex=h;let g=0;for(let w=0;w<d.length;w++){const S=d[w],E=this.getValue(S,"x",p),x=this.getValue(S,"y",p);u.setFrame(g,this.getValue(S,"time",0),E*m,x*m),this.readCurve(S,u,g),g++}l.push(u),c=Math.max(c,u.frames[(u.getFrameCount()-1)*bt.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${f} (${i})`)}}if(t.ik)for(const i in t.ik){const a=t.ik[i],h=s.findIkConstraint(i),f=new ot(a.length);f.ikConstraintIndex=s.ikConstraints.indexOf(h);let d=0;for(let u=0;u<a.length;u++){const m=a[u];f.setFrame(d,this.getValue(m,"time",0),this.getValue(m,"mix",1),this.getValue(m,"softness",0)*r,this.getValue(m,"bendPositive",!0)?1:-1,this.getValue(m,"compress",!1),this.getValue(m,"stretch",!1)),this.readCurve(m,f,d),d++}l.push(f),c=Math.max(c,f.frames[(f.getFrameCount()-1)*ot.ENTRIES])}if(t.transform)for(const i in t.transform){const a=t.transform[i],h=s.findTransformConstraint(i),f=new ut(a.length);f.transformConstraintIndex=s.transformConstraints.indexOf(h);let d=0;for(let u=0;u<a.length;u++){const m=a[u];f.setFrame(d,this.getValue(m,"time",0),this.getValue(m,"rotateMix",1),this.getValue(m,"translateMix",1),this.getValue(m,"scaleMix",1),this.getValue(m,"shearMix",1)),this.readCurve(m,f,d),d++}l.push(f),c=Math.max(c,f.frames[(f.getFrameCount()-1)*ut.ENTRIES])}if(t.path)for(const i in t.path){const a=t.path[i],h=s.findPathConstraintIndex(i);if(h==-1)throw new Error(`Path constraint not found: ${i}`);const f=s.pathConstraints[h];for(const d in a){const u=a[d];if(d==="position"||d==="spacing"){let m=null,p=1;d==="spacing"?(m=new kt(u.length),(f.spacingMode==it.Length||f.spacingMode==it.Fixed)&&(p=r)):(m=new vt(u.length),f.positionMode==Ct.Fixed&&(p=r)),m.pathConstraintIndex=h;let g=0;for(let w=0;w<u.length;w++){const S=u[w];m.setFrame(g,this.getValue(S,"time",0),this.getValue(S,d,0)*p),this.readCurve(S,m,g),g++}l.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*vt.ENTRIES])}else if(d==="mix"){const m=new Pt(u.length);m.pathConstraintIndex=h;let p=0;for(let g=0;g<u.length;g++){const w=u[g];m.setFrame(p,this.getValue(w,"time",0),this.getValue(w,"rotateMix",1),this.getValue(w,"translateMix",1)),this.readCurve(w,m,p),p++}l.push(m),c=Math.max(c,m.frames[(m.getFrameCount()-1)*Pt.ENTRIES])}}}if(t.deform)for(const i in t.deform){const a=t.deform[i],h=s.findSkin(i);if(h==null){if(Zt.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${i}`);continue}for(const f in a){const d=a[f],u=s.findSlotIndex(f);if(u==-1)throw new Error(`Slot not found: ${d.name}`);for(const m in d){const p=d[m],g=h.getAttachment(u,m);if(g==null)throw new Error(`Deform attachment not found: ${p.name}`);const w=g.bones!=null,S=g.vertices,E=w?S.length/3*2:S.length,x=new be(p.length);x.slotIndex=u,x.attachment=g;let y=0;for(let b=0;b<p.length;b++){const M=p[b];let T;const R=this.getValue(M,"vertices",null);if(R==null)T=w?k.newFloatArray(E):S;else{T=k.newFloatArray(E);const P=this.getValue(M,"offset",0);if(k.arrayCopy(R,0,T,P,R.length),r!=1)for(let v=P,_=v+R.length;v<_;v++)T[v]*=r;if(!w)for(let v=0;v<E;v++)T[v]+=S[v]}x.setFrame(y,this.getValue(M,"time",0),T),this.readCurve(M,x,y),y++}l.push(x),c=Math.max(c,x.frames[x.getFrameCount()-1])}}}let o=t.drawOrder;if(o==null&&(o=t.draworder),o!=null){const i=new jt(o.length),a=s.slots.length;let h=0;for(let f=0;f<o.length;f++){const d=o[f];let u=null;const m=this.getValue(d,"offsets",null);if(m!=null){u=k.newArray(a,-1);const p=k.newArray(a-m.length,0);let g=0,w=0;for(let S=0;S<m.length;S++){const E=m[S],x=s.findSlotIndex(E.slot);if(x==-1)throw new Error(`Slot not found: ${E.slot}`);for(;g!=x;)p[w++]=g++;u[g+E.offset]=g++}for(;g<a;)p[w++]=g++;for(let S=a-1;S>=0;S--)u[S]==-1&&(u[S]=p[--w])}i.setFrame(h++,this.getValue(d,"time",0),u)}l.push(i),c=Math.max(c,i.frames[i.getFrameCount()-1])}if(t.events){const i=new oe(t.events.length);let a=0;for(let h=0;h<t.events.length;h++){const f=t.events[h],d=s.findEvent(f.name);if(d==null)throw new Error(`Event not found: ${f.name}`);const u=new Te(k.toSinglePrecision(this.getValue(f,"time",0)),d);u.intValue=this.getValue(f,"int",d.intValue),u.floatValue=this.getValue(f,"float",d.floatValue),u.stringValue=this.getValue(f,"string",d.stringValue),u.data.audioPath!=null&&(u.volume=this.getValue(f,"volume",1),u.balance=this.getValue(f,"balance",0)),i.setFrame(a++,u)}l.push(i),c=Math.max(c,i.frames[i.getFrameCount()-1])}if(isNaN(c))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new tt(n,l,c))}readCurve(t,n,s){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")n.setStepped(s);else{const r=t.curve;n.setCurve(s,r,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,n,s){return t[n]!==void 0?t[n]:s}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return D.BLEND_MODES.NORMAL;if(t=="additive")return D.BLEND_MODES.ADD;if(t=="multiply")return D.BLEND_MODES.MULTIPLY;if(t=="screen")return D.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return Ct.Fixed;if(t=="percent")return Ct.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return it.Length;if(t=="fixed")return it.Fixed;if(t=="percent")return it.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return It.Tangent;if(t=="chain")return It.Chain;if(t=="chainscale")return It.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return z.Normal;if(t=="onlytranslation")return z.OnlyTranslation;if(t=="norotationorreflection")return z.NoRotationOrReflection;if(t=="noscale")return z.NoScale;if(t=="noscaleorreflection")return z.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}}class Pn{constructor(t,n,s,r,l){this.mesh=t,this.skin=n,this.slotIndex=s,this.parent=r,this.inheritDeform=l}}class vn extends se{createSkeleton(t){this.skeleton=new Ve(t),this.skeleton.updateWorldTransform(),this.stateData=new Ce(t),this.state=new Mt(this.stateData)}}class Vn extends An{createBinaryParser(){return new st(null)}createJsonParser(){return new Xt(null)}parseData(t,n,s){const r=t;return r.attachmentLoader=new en(n),{spineData:r.readSkeletonData(s),spineAtlas:n}}}return new Vn().installLoader(),I.Animation=tt,I.AnimationState=Mt,I.AnimationStateAdapter=In,I.AnimationStateData=Ce,I.AtlasAttachmentLoader=en,I.Attachment=Ee,I.AttachmentTimeline=Ht,I.AttachmentType=$,I.BinaryInput=De,I.Bone=Ie,I.BoneData=Re,I.BoundingBoxAttachment=re,I.ClippingAttachment=ie,I.Color=X,I.ColorTimeline=dt,I.ConstraintData=he,I.CurveTimeline=pt,I.DebugUtils=xn,I.DeformTimeline=be,I.DrawOrderTimeline=jt,I.Event=Te,I.EventData=ke,I.EventQueue=ye,I.EventTimeline=oe,I.EventType=Et,I.IkConstraint=nn,I.IkConstraintData=Pe,I.IkConstraintTimeline=ot,I.IntSet=Xe,I.Interpolation=Oe,I.JitterEffect=Cn,I.MathUtils=A,I.MeshAttachment=Ut,I.MixBlend=C,I.MixDirection=lt,I.PathAttachment=qt,I.PathConstraint=Qt,I.PathConstraintData=ve,I.PathConstraintMixTimeline=Pt,I.PathConstraintPositionTimeline=vt,I.PathConstraintSpacingTimeline=kt,I.PointAttachment=ae,I.Pool=we,I.PositionMode=Ct,I.Pow=We,I.PowOut=Ue,I.RegionAttachment=L,I.RotateMode=It,I.RotateTimeline=at,I.ScaleTimeline=wt,I.ShearTimeline=xt,I.Skeleton=Ve,I.SkeletonBinary=st,I.SkeletonBounds=kn,I.SkeletonBoundsBase=xe,I.SkeletonData=Ne,I.SkeletonJson=Xt,I.Skin=ce,I.SkinEntry=Be,I.Slot=Se,I.SlotData=Fe,I.SpacingMode=it,I.Spine=vn,I.SpineBase=se,I.SpineDebugRenderer=bn,I.SpineMesh=Ge,I.SpineSprite=He,I.StringSet=wn,I.SwirlEffect=Ke,I.TextureAtlas=ne,I.TextureAtlasPage=ge,I.TextureAtlasRegion=pe,I.TextureFilter=ht,I.TextureRegion=ee,I.TextureWrap=Rt,I.TimeKeeper=En,I.TimelineType=Je,I.TrackEntry=le,I.TransformConstraint=sn,I.TransformConstraintData=Le,I.TransformConstraintTimeline=ut,I.TransformMode=z,I.TranslateTimeline=bt,I.TwoColorTimeline=nt,I.Utils=k,I.Vector2=qe,I.VertexAttachment=_t,I.WindowedMean=Sn,I.filterFromString=me,I.settings=Zt,I.wrapFromString=mn,I}({},PIXI,PIXI,PIXI,PIXI,PIXI,PIXI);
//# sourceMappingURL=pixi-spine-3.8.js.map
